# Plan: 01-01 â€” Rate-Limited Logger Utility

## Frontmatter

| Field | Value |
|-------|-------|
| Plan ID | 01-01 |
| Phase | 1 |
| Wave | 1 |
| Depends on | none |
| Autonomous | true |
| Files modified | `packages/server/src/utils/RateLimitedLogger.ts`, `packages/server/src/utils/__tests__/RateLimitedLogger.test.ts`, `packages/server/src/ServerCoordinator.ts` |

## Objective

Create a rate-limited logging utility and integrate it with the WebSocket message validation error path to prevent log flooding from invalid messages (SEC-04).

## must_haves

- [ ] RateLimitedLogger class exists with configurable window and max-per-window settings
- [ ] Logger tracks by key, suppressing logs that exceed threshold within time window
- [ ] Summary log emitted when window resets showing count of suppressed messages
- [ ] ServerCoordinator uses RateLimitedLogger for invalid message errors
- [ ] Unit tests verify throttling behavior

## Tasks

<task id="1">
**Create RateLimitedLogger utility**

<files>packages/server/src/utils/RateLimitedLogger.ts</files>

<action>
Create a new file `RateLimitedLogger.ts` in the utils directory with:

1. Interface `RateLimitConfig`:
   - `windowMs: number` (time window in milliseconds, default 10000)
   - `maxPerWindow: number` (max logs per window per key, default 5)

2. Interface `WindowState`:
   - `count: number`
   - `suppressedCount: number`
   - `windowStart: number`

3. Class `RateLimitedLogger`:
   - Private `states: Map<string, WindowState>`
   - Private `config: RateLimitConfig`
   - Private `baseLogger` (import from `./logger`)
   - Constructor accepting optional config with defaults
   - Method `warn(key: string, obj: object, msg: string): void`
   - Method `error(key: string, obj: object, msg: string): void`
   - Private method `shouldLog(key: string): boolean` implementing:
     - Start new window if none exists or window expired
     - When starting new window, log suppression summary if any were suppressed
     - Return true if under limit, false if exceeded (incrementing suppressedCount)
   - Method `cleanup(): void` to remove stale entries (for long-running servers)

Export the class and interfaces.
</action>

<verify>
- File exists at `packages/server/src/utils/RateLimitedLogger.ts`
- TypeScript compiles: `cd packages/server && pnpm build`
</verify>

<done>RateLimitedLogger class exists with configurable throttling, exports properly, and compiles without errors</done>
</task>

<task id="2" depends_on="1">
**Add unit tests for RateLimitedLogger**

<files>packages/server/src/utils/__tests__/RateLimitedLogger.test.ts</files>

<action>
Create test file with the following test cases:

1. "should allow logs up to maxPerWindow limit":
   - Create logger with maxPerWindow: 3
   - Call error() 3 times with same key
   - Mock baseLogger and verify all 3 calls logged

2. "should suppress logs exceeding limit":
   - Create logger with maxPerWindow: 2, windowMs: 1000
   - Call error() 5 times with same key
   - Verify only 2 calls made to baseLogger.error

3. "should track different keys independently":
   - Create logger with maxPerWindow: 2
   - Call error() 3 times with key "a"
   - Call error() 3 times with key "b"
   - Verify 2 calls for each key (4 total)

4. "should reset window after windowMs expires":
   - Create logger with windowMs: 100, maxPerWindow: 1
   - Call error() twice
   - Wait 150ms
   - Call error() again
   - Verify 2 calls total (1 initial, 1 after reset)

5. "should log suppression summary when window resets":
   - Create logger with windowMs: 100, maxPerWindow: 1
   - Call error() 3 times (1 logged, 2 suppressed)
   - Wait 150ms
   - Call error() again (triggers summary + new log)
   - Verify baseLogger.warn called with suppression count

6. "should support warn method same as error":
   - Same throttling behavior for warn()

Use Jest's fake timers for time-sensitive tests.
Mock the logger module using jest.mock().
</action>

<verify>
- Tests pass: `cd packages/server && pnpm test -- --testPathPattern="RateLimitedLogger"`
</verify>

<done>All 6 test cases pass, covering throttling, key isolation, window reset, and suppression summary</done>
</task>

<task id="3" depends_on="2">
**Integrate RateLimitedLogger into ServerCoordinator**

<files>packages/server/src/ServerCoordinator.ts</files>

<action>
1. Add import at top of file:
   ```typescript
   import { RateLimitedLogger } from './utils/RateLimitedLogger';
   ```

2. Add private instance variable after other private declarations (around line 140-150):
   ```typescript
   private rateLimitedLogger: RateLimitedLogger;
   ```

3. Initialize in constructor (after other initializations, around line 310):
   ```typescript
   this.rateLimitedLogger = new RateLimitedLogger({
       windowMs: 10000,  // 10 second window
       maxPerWindow: 5   // 5 errors per client per window
   });
   ```

4. Modify the handleMessage method (around line 1363-1373). Replace:
   ```typescript
   logger.error({ clientId: client.id, error: parseResult.error }, 'Invalid message format from client');
   ```
   With:
   ```typescript
   this.rateLimitedLogger.error(
       `invalid-message:${client.id}`,
       { clientId: client.id, errorCode: parseResult.error.issues[0]?.code },
       'Invalid message format from client'
   );
   ```

Note: Only log errorCode, not full error object (prevents log bloat even when not suppressed).
</action>

<verify>
- Build succeeds: `cd packages/server && pnpm build`
- Existing tests pass: `cd packages/server && pnpm test -- --testPathPattern="ServerCoordinator"`
</verify>

<done>ServerCoordinator uses RateLimitedLogger for invalid WebSocket messages, build and tests pass</done>
</task>

## Verification

After all tasks complete:

1. Build passes: `pnpm --filter @topgunbuild/server build`
2. All server tests pass: `pnpm --filter @topgunbuild/server test`
3. RateLimitedLogger tests specifically pass with coverage of throttling behavior
4. Invalid messages are logged with rate limiting (manual test or inspection)

## Success Criteria

- [x] RateLimitedLogger utility exists with tests
- [x] ServerCoordinator integrates rate-limited logging for invalid messages
- [x] Log flooding from malicious clients sending invalid messages is prevented
- [x] Suppression summary provides visibility into attack patterns
