---
phase: 03-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/adapter-better-auth/src/TopGunAdapter.ts
  - packages/adapter-better-auth/src/__tests__/TopGunAdapter.test.ts
autonomous: true

must_haves:
  truths:
    - "BetterAuth adapter waits for storage to be ready before first request"
    - "Concurrent requests during initialization all wait for same ready promise"
    - "Subsequent requests after ready do not wait"
  artifacts:
    - path: "packages/adapter-better-auth/src/TopGunAdapter.ts"
      provides: "ensureReady() function and waitForReady option"
      contains: "ensureReady"
    - path: "packages/adapter-better-auth/src/__tests__/TopGunAdapter.test.ts"
      provides: "Cold start race condition tests"
      contains: "waitForReady"
  key_links:
    - from: "TopGunAdapter.create"
      to: "ensureReady()"
      via: "await call at method start"
      pattern: "await ensureReady"
---

# 03-01: BetterAuth Cold Start Fix

**Objective:** Fix race condition where BetterAuth adapter returns empty results before TopGunClient storage has loaded.

**Requirements:** BUG-05

## Context

@.planning/phases/03-bug-fixes/03-RESEARCH.md (BUG-05 section)
@packages/adapter-better-auth/src/TopGunAdapter.ts
@packages/client/src/adapters/IDBAdapter.ts (pattern reference: waitForReady)

## Tasks

<task id="1">
<title>Add ensureReady gate to TopGunAdapter</title>
<instructions>
Modify `packages/adapter-better-auth/src/TopGunAdapter.ts`:

1. Add `waitForReady` option to `TopGunAdapterOptions` interface:
```typescript
export interface TopGunAdapterOptions {
  client: TopGunClient;
  modelMap?: Record<string, string>;
  /** Wait for client storage to be ready before accepting requests (default: true) */
  waitForReady?: boolean;
}
```

2. Inside `topGunAdapter` function, add ready state tracking after `getMapName` function:
```typescript
const shouldWaitForReady = adapterOptions.waitForReady ?? true;
let isReady = false;
let readyPromise: Promise<void> | null = null;

const ensureReady = async (): Promise<void> => {
  if (!shouldWaitForReady || isReady) return;
  if (!readyPromise) {
    // client.start() ensures storage is initialized and loaded
    readyPromise = client.start().then(() => {
      isReady = true;
    });
  }
  await readyPromise;
};
```

3. Add `await ensureReady()` as first line in these adapter methods:
- `create` (line ~104)
- `findOne` (line ~120)
- `findMany` (line ~200)
- `update` (line ~205)
- `updateMany` (line ~226)
- `delete` (line ~237)
- `deleteMany` (line ~247)
- `count` (line ~258)

Do NOT add to `runQuery` (internal helper) or `transaction` (delegates to other methods).

4. Remove or update the TODO comment at lines 126-134 that describes the race condition (the fix addresses it).
</instructions>
<acceptance>
- [ ] `TopGunAdapterOptions` interface has `waitForReady?: boolean` field
- [ ] `ensureReady()` function exists and gates on `client.start()`
- [ ] All 8 public adapter methods call `await ensureReady()` first
- [ ] TypeScript compiles without errors: `pnpm --filter @topgunbuild/adapter-better-auth build`
</acceptance>
</task>

<task id="2">
<title>Add cold start tests to TopGunAdapter.test.ts</title>
<instructions>
Modify `packages/adapter-better-auth/src/__tests__/TopGunAdapter.test.ts`:

1. Add test for ready gating:
```typescript
describe('cold start handling', () => {
  it('waits for storage ready before first operation', async () => {
    // Create a mock client with delayed start
    let startResolved = false;
    const mockClient = {
      start: jest.fn().mockImplementation(() => {
        return new Promise<void>(resolve => {
          setTimeout(() => {
            startResolved = true;
            resolve();
          }, 50);
        });
      }),
      getMap: jest.fn().mockReturnValue({
        set: jest.fn(),
        get: jest.fn(),
        remove: jest.fn(),
      }),
      query: jest.fn().mockReturnValue({
        subscribe: jest.fn((cb) => {
          cb([]);
          return () => {};
        }),
      }),
    };

    const adapter = topGunAdapter({ client: mockClient as any })({} as any);

    // Start operation before storage is ready
    const createPromise = adapter.create({ model: 'user', data: { name: 'test' } });

    // Verify start was called
    expect(mockClient.start).toHaveBeenCalled();

    // Wait for create to complete
    await createPromise;

    // Verify storage was ready before create proceeded
    expect(startResolved).toBe(true);
  });

  it('concurrent requests share same ready promise', async () => {
    let startCallCount = 0;
    const mockClient = {
      start: jest.fn().mockImplementation(() => {
        startCallCount++;
        return new Promise<void>(resolve => setTimeout(resolve, 50));
      }),
      getMap: jest.fn().mockReturnValue({
        set: jest.fn(),
        get: jest.fn(),
      }),
      query: jest.fn().mockReturnValue({
        subscribe: jest.fn((cb) => {
          cb([]);
          return () => {};
        }),
      }),
    };

    const adapter = topGunAdapter({ client: mockClient as any })({} as any);

    // Fire multiple concurrent requests
    await Promise.all([
      adapter.create({ model: 'user', data: { name: 'test1' } }),
      adapter.create({ model: 'user', data: { name: 'test2' } }),
      adapter.findMany({ model: 'user' }),
    ]);

    // start() should only be called once
    expect(startCallCount).toBe(1);
  });

  it('subsequent requests do not wait if already ready', async () => {
    let startCallCount = 0;
    const mockClient = {
      start: jest.fn().mockImplementation(() => {
        startCallCount++;
        return Promise.resolve();
      }),
      getMap: jest.fn().mockReturnValue({
        set: jest.fn(),
      }),
      query: jest.fn().mockReturnValue({
        subscribe: jest.fn((cb) => {
          cb([]);
          return () => {};
        }),
      }),
    };

    const adapter = topGunAdapter({ client: mockClient as any })({} as any);

    // First request triggers ready
    await adapter.create({ model: 'user', data: { name: 'test1' } });

    // Second request should not call start again
    await adapter.create({ model: 'user', data: { name: 'test2' } });

    expect(startCallCount).toBe(1);
  });

  it('can disable waitForReady via option', async () => {
    const mockClient = {
      start: jest.fn(),
      getMap: jest.fn().mockReturnValue({
        set: jest.fn(),
      }),
    };

    const adapter = topGunAdapter({
      client: mockClient as any,
      waitForReady: false
    })({} as any);

    await adapter.create({ model: 'user', data: { name: 'test' } });

    // start() should not be called when waitForReady is false
    expect(mockClient.start).not.toHaveBeenCalled();
  });
});
```

2. Ensure all tests pass: `pnpm --filter @topgunbuild/adapter-better-auth test`
</instructions>
<acceptance>
- [ ] 4 new tests in `cold start handling` describe block
- [ ] Tests verify ready gating, concurrent promise sharing, subsequent no-wait, and opt-out
- [ ] All tests pass: `pnpm --filter @topgunbuild/adapter-better-auth test`
</acceptance>
</task>

## Verification

<verification>
<command>pnpm --filter @topgunbuild/adapter-better-auth test && pnpm --filter @topgunbuild/adapter-better-auth build</command>
<expected>All tests pass, build succeeds with no TypeScript errors</expected>
</verification>

## must_haves

These are derived from the phase goal. If any is FALSE after execution, the plan has FAILED:

- [ ] BetterAuth adapter methods await `ensureReady()` before accessing maps
- [ ] `client.start()` is called exactly once even with concurrent requests
- [ ] Requests after initialization do not incur additional wait
- [ ] Option exists to disable ready gating for advanced use cases

## Success Criteria

- BetterAuth adapter prevents race condition on cold start
- All adapter tests pass
- Package builds without errors
