---
phase: 03-bug-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/client/src/SyncEngine.ts
  - packages/client/src/__tests__/SyncEngine.test.ts
autonomous: true

must_haves:
  truths:
    - "Topic messages published offline are queued in memory"
    - "Queued messages are flushed when client reconnects and authenticates"
    - "Queue has configurable max size with drop-oldest eviction"
  artifacts:
    - path: "packages/client/src/SyncEngine.ts"
      provides: "Topic queue with configurable size and flush on reconnect"
      contains: "topicQueue"
    - path: "packages/client/src/__tests__/SyncEngine.test.ts"
      provides: "Topic offline queue tests"
      contains: "topic.*queue"
  key_links:
    - from: "SyncEngine.publishTopic"
      to: "topicQueue"
      via: "queueTopicMessage when offline"
      pattern: "queueTopicMessage"
    - from: "AUTH_ACK handler"
      to: "flushTopicQueue"
      via: "call after authentication"
      pattern: "flushTopicQueue"
---

# 03-02: Topic Offline Queue

**Objective:** Queue topic messages when client is offline and flush them on reconnection.

**Requirements:** BUG-06

## Context

@.planning/phases/03-bug-fixes/03-RESEARCH.md (BUG-06 section)
@packages/client/src/SyncEngine.ts (lines 632-645: publishTopic, line 819: AUTH_ACK)
@packages/client/src/BackpressureConfig.ts (pattern reference: queue config)

## Tasks

<task id="1">
<title>Add TopicQueueConfig and queue implementation to SyncEngine</title>
<instructions>
Modify `packages/client/src/SyncEngine.ts`:

1. Add TopicQueueConfig interface near other config interfaces (around line 65):
```typescript
export interface TopicQueueConfig {
  /** Maximum queued topic messages when offline (default: 100) */
  maxSize: number;
  /** Strategy when queue is full: 'drop-oldest' | 'drop-newest' (default: 'drop-oldest') */
  strategy: 'drop-oldest' | 'drop-newest';
}

const DEFAULT_TOPIC_QUEUE_CONFIG: TopicQueueConfig = {
  maxSize: 100,
  strategy: 'drop-oldest',
};
```

2. Add `topicQueue` field to `SyncEngineConfig` interface (around line 76):
```typescript
export interface SyncEngineConfig {
  // ... existing fields
  /** Configuration for offline topic message queue */
  topicQueue?: Partial<TopicQueueConfig>;
}
```

3. Add private fields to SyncEngine class (after line ~100):
```typescript
interface QueuedTopicMessage {
  topic: string;
  data: any;
  timestamp: number;
}

// In class body:
private topicQueue: QueuedTopicMessage[] = [];
private readonly topicQueueConfig: TopicQueueConfig;
```

4. Initialize topicQueueConfig in constructor:
```typescript
this.topicQueueConfig = {
  ...DEFAULT_TOPIC_QUEUE_CONFIG,
  ...config.topicQueue,
};
```

5. Add private helper methods after `publishTopic` method (around line 645):
```typescript
private queueTopicMessage(topic: string, data: any): void {
  const message: QueuedTopicMessage = {
    topic,
    data,
    timestamp: Date.now(),
  };

  if (this.topicQueue.length >= this.topicQueueConfig.maxSize) {
    if (this.topicQueueConfig.strategy === 'drop-oldest') {
      const dropped = this.topicQueue.shift();
      logger.warn({ topic: dropped?.topic }, 'Dropped oldest queued topic message (queue full)');
    } else {
      logger.warn({ topic }, 'Dropped newest topic message (queue full)');
      return;
    }
  }

  this.topicQueue.push(message);
  logger.debug({ topic, queueSize: this.topicQueue.length }, 'Queued topic message for offline');
}

private flushTopicQueue(): void {
  if (this.topicQueue.length === 0) return;

  logger.info({ count: this.topicQueue.length }, 'Flushing queued topic messages');

  for (const msg of this.topicQueue) {
    this.sendMessage({
      type: 'TOPIC_PUB',
      payload: { topic: msg.topic, data: msg.data },
    });
  }

  this.topicQueue = [];
}
```

6. Add public method for queue status monitoring:
```typescript
public getTopicQueueStatus(): { size: number; maxSize: number } {
  return {
    size: this.topicQueue.length,
    maxSize: this.topicQueueConfig.maxSize,
  };
}
```

7. Modify `publishTopic` method (lines 632-645) to queue when offline:
```typescript
public publishTopic(topic: string, data: any) {
  if (this.isAuthenticated()) {
    this.sendMessage({
      type: 'TOPIC_PUB',
      payload: { topic, data }
    });
  } else {
    this.queueTopicMessage(topic, data);
  }
}
```

8. In the `AUTH_ACK` case handler (around line 819), add flush call after authentication:
```typescript
case 'AUTH_ACK': {
  logger.info('Authenticated successfully');
  const wasAuthenticated = this.isAuthenticated();

  // Transition to SYNCING state
  this.stateMachine.transition(SyncState.SYNCING);

  // Flush any queued topic messages from offline period
  this.flushTopicQueue();

  // ... rest of existing code
```
</instructions>
<acceptance>
- [ ] `TopicQueueConfig` interface exported with `maxSize` and `strategy` fields
- [ ] `SyncEngineConfig` has optional `topicQueue` field
- [ ] `queueTopicMessage()` and `flushTopicQueue()` private methods exist
- [ ] `getTopicQueueStatus()` public method exists
- [ ] `publishTopic()` calls `queueTopicMessage()` when offline instead of just logging
- [ ] `AUTH_ACK` handler calls `flushTopicQueue()`
- [ ] TypeScript compiles: `pnpm --filter @topgunbuild/client build`
</acceptance>
</task>

<task id="2">
<title>Add topic queue tests to SyncEngine.test.ts</title>
<instructions>
Modify `packages/client/src/__tests__/SyncEngine.test.ts`:

1. Add a new describe block for topic queue tests. Find appropriate location in the file and add:
```typescript
describe('topic offline queue', () => {
  let mockStorageAdapter: any;
  let syncEngine: SyncEngine;

  beforeEach(() => {
    mockStorageAdapter = {
      initialize: jest.fn().mockResolvedValue(undefined),
      get: jest.fn().mockResolvedValue(null),
      put: jest.fn().mockResolvedValue(undefined),
      remove: jest.fn().mockResolvedValue(undefined),
      getAllKeys: jest.fn().mockResolvedValue([]),
      getMeta: jest.fn().mockResolvedValue(null),
      setMeta: jest.fn().mockResolvedValue(undefined),
      appendOpLog: jest.fn().mockResolvedValue(undefined),
      getUnsyncedOps: jest.fn().mockResolvedValue([]),
      markOpsSynced: jest.fn().mockResolvedValue(undefined),
      close: jest.fn().mockResolvedValue(undefined),
    };
  });

  afterEach(async () => {
    if (syncEngine) {
      await syncEngine.stop();
    }
  });

  it('queues topic messages when offline', () => {
    syncEngine = new SyncEngine({
      nodeId: 'test-node',
      serverUrl: 'ws://localhost:9999',
      storageAdapter: mockStorageAdapter,
    });

    // Not authenticated = offline
    syncEngine.publishTopic('chat', { message: 'hello' });
    syncEngine.publishTopic('chat', { message: 'world' });

    const status = syncEngine.getTopicQueueStatus();
    expect(status.size).toBe(2);
    expect(status.maxSize).toBe(100); // default
  });

  it('respects maxSize with drop-oldest strategy', () => {
    syncEngine = new SyncEngine({
      nodeId: 'test-node',
      serverUrl: 'ws://localhost:9999',
      storageAdapter: mockStorageAdapter,
      topicQueue: { maxSize: 3, strategy: 'drop-oldest' },
    });

    // Queue 5 messages with maxSize 3
    for (let i = 0; i < 5; i++) {
      syncEngine.publishTopic('chat', { index: i });
    }

    const status = syncEngine.getTopicQueueStatus();
    expect(status.size).toBe(3);
    expect(status.maxSize).toBe(3);
  });

  it('respects drop-newest strategy', () => {
    syncEngine = new SyncEngine({
      nodeId: 'test-node',
      serverUrl: 'ws://localhost:9999',
      storageAdapter: mockStorageAdapter,
      topicQueue: { maxSize: 2, strategy: 'drop-newest' },
    });

    syncEngine.publishTopic('chat', { index: 0 });
    syncEngine.publishTopic('chat', { index: 1 });
    syncEngine.publishTopic('chat', { index: 2 }); // dropped

    const status = syncEngine.getTopicQueueStatus();
    expect(status.size).toBe(2);
  });

  it('returns correct default config', () => {
    syncEngine = new SyncEngine({
      nodeId: 'test-node',
      serverUrl: 'ws://localhost:9999',
      storageAdapter: mockStorageAdapter,
    });

    const status = syncEngine.getTopicQueueStatus();
    expect(status.maxSize).toBe(100);
  });
});
```

2. Note: Testing the flush on AUTH_ACK would require WebSocket mocking which is complex. The unit tests above verify the queue mechanics. Integration testing of flush can be manual or in a dedicated integration test file.

3. Run tests: `pnpm --filter @topgunbuild/client test -- --testPathPattern=SyncEngine`
</instructions>
<acceptance>
- [ ] `topic offline queue` describe block added with 4 tests
- [ ] Tests verify: queueing when offline, drop-oldest, drop-newest, default config
- [ ] All SyncEngine tests pass: `pnpm --filter @topgunbuild/client test -- --testPathPattern=SyncEngine`
</acceptance>
</task>

## Verification

<verification>
<command>pnpm --filter @topgunbuild/client test -- --testPathPattern=SyncEngine && pnpm --filter @topgunbuild/client build</command>
<expected>All SyncEngine tests pass, build succeeds with no TypeScript errors</expected>
</verification>

## must_haves

These are derived from the phase goal. If any is FALSE after execution, the plan has FAILED:

- [ ] Topic messages are queued when `isAuthenticated()` returns false
- [ ] Queue respects configurable `maxSize` limit
- [ ] Queue uses `drop-oldest` eviction by default when full
- [ ] Queue is flushed automatically on successful authentication (AUTH_ACK)
- [ ] `getTopicQueueStatus()` allows monitoring queue state

## Success Criteria

- Topic messages published offline are retained and sent on reconnect
- Queue size is bounded to prevent memory issues
- All client package tests pass
- Package builds without errors
