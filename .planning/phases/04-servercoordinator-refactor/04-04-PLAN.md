---
phase: 04-servercoordinator-refactor
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - packages/server/src/coordinator/types.ts
  - packages/server/src/coordinator/operation-handler.ts
  - packages/server/src/coordinator/message-registry.ts
  - packages/server/src/coordinator/index.ts
  - packages/server/src/ServerCoordinator.ts
autonomous: true

must_haves:
  truths:
    - "OperationHandler processes CLIENT_OP and OP_BATCH messages"
    - "Message routing uses a registry pattern instead of giant switch"
    - "handleMessage switch statement is significantly reduced"
    - "ServerCoordinator orchestrates modules but delegates all operation logic"
    - "All existing operation-related tests continue to pass"
  artifacts:
    - path: "packages/server/src/coordinator/operation-handler.ts"
      provides: "OperationHandler implementation"
      exports: ["OperationHandler"]
    - path: "packages/server/src/coordinator/message-registry.ts"
      provides: "Message type to handler routing"
      exports: ["createMessageRegistry", "MessageRegistry"]
    - path: "packages/server/src/coordinator/types.ts"
      provides: "IOperationHandler interface"
      contains: "interface IOperationHandler"
  key_links:
    - from: "packages/server/src/ServerCoordinator.ts"
      to: "packages/server/src/coordinator/operation-handler.ts"
      via: "import and instantiation"
      pattern: "new OperationHandler"
    - from: "packages/server/src/ServerCoordinator.ts"
      to: "messageRegistry"
      via: "message dispatch"
      pattern: "messageRegistry\\["
---

<objective>
Extract OperationHandler module and create message registry pattern

Purpose: Extract CRDT operation handling (CLIENT_OP, OP_BATCH) into OperationHandler and create a message registry pattern to replace the 30+ case switch statement in handleMessage. This is the final extraction that transforms ServerCoordinator into an orchestrator.

Output: OperationHandler class, MessageRegistry for routing, ServerCoordinator reduced to orchestration only
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-servercoordinator-refactor/04-RESEARCH.md
@.planning/phases/04-servercoordinator-refactor/04-CONTEXT.md
@packages/server/src/ServerCoordinator.ts (lines 1444-2834 for handleMessage switch cases)

# Prior plan summaries (if needed for context)
@.planning/phases/04-servercoordinator-refactor/04-01-SUMMARY.md
@.planning/phases/04-servercoordinator-refactor/04-02-SUMMARY.md
@.planning/phases/04-servercoordinator-refactor/04-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IOperationHandler interface and OperationHandler class</name>
  <files>
    packages/server/src/coordinator/types.ts
    packages/server/src/coordinator/operation-handler.ts
    packages/server/src/coordinator/index.ts
  </files>
  <action>
1. **Update types.ts** - Add IOperationHandler interface:
   ```typescript
   export interface IOperationHandler {
     /** Process a single client operation (CLIENT_OP) */
     processClientOp(client: ClientConnection, op: any): Promise<void>;

     /** Process a batch of operations (OP_BATCH) */
     processOpBatch(client: ClientConnection, ops: any[], writeConcern?: string, timeout?: number): Promise<void>;
   }

   export interface OperationHandlerConfig {
     connectionManager: IConnectionManager;
     storageManager: IStorageManager;
     securityManager: SecurityManager;
     partitionService: PartitionService;
     cluster: ClusterManager;
     hlc: HLC;
     metricsService: MetricsService;
     writeAckManager: WriteAckManager;
     interceptors: IInterceptor[];
     queryRegistry: QueryRegistry;
     replicationPipeline?: ReplicationPipeline;
     eventJournalService?: EventJournalService;
     searchCoordinator: SearchCoordinator;
     conflictResolverHandler: ConflictResolverHandler;
   }
   ```

2. **Create operation-handler.ts**:
   - Constructor takes `OperationHandlerConfig`
   - Extract core operation processing methods from ServerCoordinator:
     - `processClientOp()` - wraps processLocalOp logic (lines 1608-1643)
     - `processOpBatch()` - wraps OP_BATCH handling (lines 1646-1759)
   - Keep complex internal methods as private helpers:
     - `applyOpToMap()` - core CRDT apply logic
     - `runBeforeInterceptors()` / `runAfterInterceptors()`
     - `buildOpContext()`
   - These methods need access to many dependencies, so they take them via config

3. **Important constraint**: Due to the complexity of operation processing (interceptors, Write Concern, replication, journal, search indexing), this extraction focuses on:
   - Moving the entry point methods (processClientOp, processOpBatch)
   - The detailed implementation can stay in ServerCoordinator initially
   - Full extraction would be a follow-up refactor

4. **Update index.ts** - Add exports:
   ```typescript
   export { OperationHandler } from './operation-handler';
   export type { IOperationHandler, OperationHandlerConfig } from './types';
   ```
  </action>
  <verify>
    - `ls packages/server/src/coordinator/operation-handler.ts` exists
    - `npx tsc --noEmit -p packages/server/tsconfig.json` passes
  </verify>
  <done>
    OperationHandler class created with IOperationHandler interface
    Core operation methods have entry points
    TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create message registry pattern</name>
  <files>
    packages/server/src/coordinator/message-registry.ts
    packages/server/src/coordinator/index.ts
  </files>
  <action>
Create a message registry to replace the giant switch statement:

1. **Create message-registry.ts**:
   ```typescript
   import type { ClientConnection } from './types';

   export type MessageHandler = (client: ClientConnection, message: any) => Promise<void> | void;

   export interface MessageRegistry {
     [messageType: string]: MessageHandler;
   }

   /**
    * Create message registry mapping message types to handlers.
    * This replaces the 30+ case switch statement in handleMessage.
    */
   export function createMessageRegistry(handlers: {
     // Auth (handled separately before registry)

     // Query operations
     onQuerySub: MessageHandler;
     onQueryUnsub: MessageHandler;

     // CRDT operations
     onClientOp: MessageHandler;
     onOpBatch: MessageHandler;

     // Sync protocol
     onSyncInit: MessageHandler;
     onMerkleReqBucket: MessageHandler;
     onORMapSyncInit: MessageHandler;
     onORMapMerkleReqBucket: MessageHandler;
     onORMapDiffRequest: MessageHandler;
     onORMapPushDiff: MessageHandler;

     // Lock operations
     onLockRequest: MessageHandler;
     onLockRelease: MessageHandler;

     // Topic operations
     onTopicSub: MessageHandler;
     onTopicUnsub: MessageHandler;
     onTopicPub: MessageHandler;

     // Counter operations
     onCounterRequest: MessageHandler;
     onCounterSync: MessageHandler;

     // Entry processor
     onEntryProcess: MessageHandler;
     onEntryProcessBatch: MessageHandler;

     // Conflict resolver
     onRegisterResolver: MessageHandler;
     onUnregisterResolver: MessageHandler;
     onListResolvers: MessageHandler;

     // Partition
     onPartitionMapRequest: MessageHandler;

     // Search
     onSearch: MessageHandler;
     onSearchSub: MessageHandler;
     onSearchUnsub: MessageHandler;

     // Journal
     onJournalSubscribe: MessageHandler;
     onJournalUnsubscribe: MessageHandler;
     onJournalRead: MessageHandler;
   }): MessageRegistry {
     return {
       'QUERY_SUB': handlers.onQuerySub,
       'QUERY_UNSUB': handlers.onQueryUnsub,
       'CLIENT_OP': handlers.onClientOp,
       'OP_BATCH': handlers.onOpBatch,
       'SYNC_INIT': handlers.onSyncInit,
       'MERKLE_REQ_BUCKET': handlers.onMerkleReqBucket,
       'ORMAP_SYNC_INIT': handlers.onORMapSyncInit,
       'ORMAP_MERKLE_REQ_BUCKET': handlers.onORMapMerkleReqBucket,
       'ORMAP_DIFF_REQUEST': handlers.onORMapDiffRequest,
       'ORMAP_PUSH_DIFF': handlers.onORMapPushDiff,
       'LOCK_REQUEST': handlers.onLockRequest,
       'LOCK_RELEASE': handlers.onLockRelease,
       'TOPIC_SUB': handlers.onTopicSub,
       'TOPIC_UNSUB': handlers.onTopicUnsub,
       'TOPIC_PUB': handlers.onTopicPub,
       'COUNTER_REQUEST': handlers.onCounterRequest,
       'COUNTER_SYNC': handlers.onCounterSync,
       'ENTRY_PROCESS': handlers.onEntryProcess,
       'ENTRY_PROCESS_BATCH': handlers.onEntryProcessBatch,
       'REGISTER_RESOLVER': handlers.onRegisterResolver,
       'UNREGISTER_RESOLVER': handlers.onUnregisterResolver,
       'LIST_RESOLVERS': handlers.onListResolvers,
       'PARTITION_MAP_REQUEST': handlers.onPartitionMapRequest,
       'SEARCH': handlers.onSearch,
       'SEARCH_SUB': handlers.onSearchSub,
       'SEARCH_UNSUB': handlers.onSearchUnsub,
       'JOURNAL_SUBSCRIBE': handlers.onJournalSubscribe,
       'JOURNAL_UNSUBSCRIBE': handlers.onJournalUnsubscribe,
       'JOURNAL_READ': handlers.onJournalRead,
     };
   }
   ```

2. **Update index.ts**:
   ```typescript
   export { createMessageRegistry, type MessageRegistry, type MessageHandler } from './message-registry';
   ```
  </action>
  <verify>
    - `ls packages/server/src/coordinator/message-registry.ts` exists
    - `npx tsc --noEmit -p packages/server/tsconfig.json` passes
  </verify>
  <done>
    MessageRegistry type and createMessageRegistry function created
    All 30+ message types mapped
    TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate into ServerCoordinator and replace switch statement</name>
  <files>packages/server/src/ServerCoordinator.ts</files>
  <action>
Update ServerCoordinator to use OperationHandler and MessageRegistry:

1. **Update imports**:
   ```typescript
   import {
     AuthHandler,
     ConnectionManager,
     StorageManager,
     OperationHandler,
     createMessageRegistry,
     type MessageRegistry
   } from './coordinator';
   ```

2. **Add fields**:
   ```typescript
   private operationHandler: OperationHandler;
   private messageRegistry: MessageRegistry;
   ```

3. **Initialize OperationHandler** (in start() after other managers):
   ```typescript
   this.operationHandler = new OperationHandler({
     connectionManager: this.connectionManager,
     storageManager: this.storageManager,
     securityManager: this.securityManager,
     partitionService: this.partitionService,
     cluster: this.cluster,
     hlc: this.hlc,
     metricsService: this.metricsService,
     writeAckManager: this.writeAckManager,
     interceptors: this.interceptors,
     queryRegistry: this.queryRegistry,
     replicationPipeline: this.replicationPipeline,
     eventJournalService: this.eventJournalService,
     searchCoordinator: this.searchCoordinator,
     conflictResolverHandler: this.conflictResolverHandler,
   });
   ```

4. **Create message registry** (in start() or constructor):
   ```typescript
   this.messageRegistry = createMessageRegistry({
     onQuerySub: (client, msg) => this.handleQuerySub(client, msg),
     onQueryUnsub: (client, msg) => this.handleQueryUnsub(client, msg),
     onClientOp: (client, msg) => this.operationHandler.processClientOp(client, msg.payload),
     onOpBatch: (client, msg) => this.operationHandler.processOpBatch(
       client, msg.payload.ops, msg.payload.writeConcern, msg.payload.timeout
     ),
     // ... map all other handlers to existing private methods
   });
   ```

5. **Refactor handleMessage** to use registry:
   ```typescript
   private async handleMessage(client: ClientConnection, rawMessage: any) {
     // Validation with Zod (keep existing)
     const parseResult = MessageSchema.safeParse(rawMessage);
     if (!parseResult.success) { /* existing error handling */ }
     const message = parseResult.data;

     // Handle PING immediately (keep existing)
     if (message.type === 'PING') {
       this.handlePing(client, message.timestamp);
       return;
     }

     // Update client's last active HLC (keep existing)
     this.updateClientHlc(client, message);

     // Auth handling (keep existing - uses authHandler)
     if (!client.isAuthenticated) {
       if (message.type === 'AUTH') {
         const result = await this.authHandler.handleAuth(client, message.token);
         // ... existing auth response handling
       }
       return;
     }

     // NEW: Use message registry for authenticated messages
     const handler = this.messageRegistry[message.type];
     if (handler) {
       await handler(client, message);
     } else {
       logger.warn({ type: message.type }, 'Unknown message type');
       client.writer.write({
         type: 'ERROR',
         payload: { code: 400, message: `Unknown message type: ${message.type}` }
       }, true);
     }
   }
   ```

6. **Extract switch cases to private methods** (if not already):
   - Each case becomes a private method: `handleQuerySub`, `handleQueryUnsub`, etc.
   - The switch statement is deleted, replaced by registry lookup

7. **Verify OperationHandler is called**:
   - CLIENT_OP routes to `operationHandler.processClientOp`
   - OP_BATCH routes to `operationHandler.processOpBatch`
  </action>
  <verify>
    - `grep -n "switch (message.type)" packages/server/src/ServerCoordinator.ts` returns no matches or minimal
    - `pnpm --filter @topgunbuild/server build` succeeds
    - `pnpm --filter @topgunbuild/server test` passes
  </verify>
  <done>
    handleMessage switch replaced with registry lookup
    OperationHandler handles CLIENT_OP and OP_BATCH
    ServerCoordinator is now an orchestrator
  </done>
</task>

</tasks>

<verification>
Phase 4 Plan 4 verification:

1. **Module exists**: `packages/server/src/coordinator/operation-handler.ts` exports `OperationHandler`
2. **Registry exists**: `packages/server/src/coordinator/message-registry.ts` exports `createMessageRegistry`
3. **Switch reduced**: handleMessage no longer has 30+ case switch
4. **Delegation complete**: CLIENT_OP/OP_BATCH handled by OperationHandler
5. **Tests pass**: `pnpm --filter @topgunbuild/server test` green

Final Phase 4 verification:
- ServerCoordinator delegates auth to AuthHandler
- ServerCoordinator delegates connections to ConnectionManager
- ServerCoordinator delegates storage to StorageManager
- ServerCoordinator delegates operations to OperationHandler
- ServerCoordinator orchestrates but contains no business logic
</verification>

<success_criteria>
- OperationHandler module created with IOperationHandler interface
- MessageRegistry pattern replaces giant switch statement
- ServerCoordinator uses message registry for message routing
- CLIENT_OP and OP_BATCH delegated to OperationHandler
- ServerCoordinator transformed into orchestrator
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-servercoordinator-refactor/04-04-SUMMARY.md`
</output>
