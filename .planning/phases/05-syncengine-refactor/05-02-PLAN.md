---
phase: 05-syncengine-refactor
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - packages/client/src/sync/types.ts
  - packages/client/src/sync/QueryManager.ts
  - packages/client/src/sync/index.ts
  - packages/client/src/SyncEngine.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SyncEngine delegates all query operations to QueryManager"
    - "QueryManager owns queries Map and hybridQueries Map"
    - "Query subscriptions are sent via callback to SyncEngine for message sending"
    - "Local queries execute against storage adapter"
  artifacts:
    - path: "packages/client/src/sync/types.ts"
      provides: "IQueryManager interface"
      contains: "interface IQueryManager"
    - path: "packages/client/src/sync/QueryManager.ts"
      provides: "QueryManager implementation"
      exports: ["QueryManager", "QueryManagerConfig"]
  key_links:
    - from: "packages/client/src/SyncEngine.ts"
      to: "packages/client/src/sync/QueryManager.ts"
      via: "constructor injection"
      pattern: "this\\.queryManager = new QueryManager"
    - from: "packages/client/src/sync/QueryManager.ts"
      to: "SyncEngine.sendMessage"
      via: "sendMessage callback"
      pattern: "sendMessage\\("
---

<objective>
Extract QueryManager class from SyncEngine to handle all query operations.

Purpose: QueryManager will own the queries Map and hybridQueries Map (single source of truth), handling subscriptions, unsubscriptions, and local query execution. It depends on WebSocketManager being extracted first (for message sending via callback).

Output: QueryManager class added to `packages/client/src/sync/` folder.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-syncengine-refactor/05-RESEARCH.md
@.planning/phases/05-syncengine-refactor/05-01-SUMMARY.md

@packages/client/src/SyncEngine.ts
@packages/client/src/sync/types.ts
@packages/client/src/QueryHandle.ts
@packages/client/src/HybridQueryHandle.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QueryManager types</name>
  <files>
    packages/client/src/sync/types.ts
  </files>
  <action>
Extend types.ts with QueryManager interface:

1. Add `IQueryManager` interface:
   ```typescript
   export interface IQueryManager {
     /** Get all queries (read-only access) */
     getQueries(): Map<string, QueryHandle<any>>;

     /** Get all hybrid queries */
     getHybridQueries(): Map<string, HybridQueryHandle<any>>;

     /** Subscribe to a standard query */
     subscribeToQuery(query: QueryHandle<any>): void;

     /** Unsubscribe from a query */
     unsubscribeFromQuery(queryId: string): void;

     /** Subscribe to a hybrid query (FTS + filter) */
     subscribeToHybridQuery<T>(query: HybridQueryHandle<T>): void;

     /** Unsubscribe from a hybrid query */
     unsubscribeFromHybridQuery(queryId: string): void;

     /** Get a hybrid query by ID */
     getHybridQuery(queryId: string): HybridQueryHandle<any> | undefined;

     /** Run a local query against storage */
     runLocalQuery(mapName: string, filter: QueryFilter): Promise<{ key: string; value: any }[]>;

     /** Run a local hybrid query */
     runLocalHybridQuery<T>(mapName: string, filter: HybridQueryFilter): Promise<Array<{ key: string; value: T; score?: number; matchedTerms?: string[] }>>;

     /** Re-subscribe all queries (called after auth) */
     resubscribeAll(): void;
   }
   ```

2. Add `QueryManagerConfig` interface:
   ```typescript
   export interface QueryManagerConfig {
     /** Storage adapter for local queries */
     storageAdapter: IStorageAdapter;
     /** Callback to send messages via SyncEngine/WebSocketManager */
     sendMessage: (message: any, key?: string) => boolean;
     /** Callback to check if authenticated */
     isAuthenticated: () => boolean;
   }
   ```

3. Add necessary imports at top:
   - Import QueryHandle, QueryFilter from '../QueryHandle'
   - Import HybridQueryHandle, HybridQueryFilter from '../HybridQueryHandle'
   - Import IStorageAdapter from '../IStorageAdapter'
  </action>
  <verify>
TypeScript compiles: `cd packages/client && npx tsc --noEmit`
  </verify>
  <done>
IQueryManager and QueryManagerConfig interfaces defined in types.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement QueryManager class</name>
  <files>
    packages/client/src/sync/QueryManager.ts
    packages/client/src/sync/index.ts
  </files>
  <action>
Create QueryManager class implementing IQueryManager:

1. Create `packages/client/src/sync/QueryManager.ts`:

2. Constructor injection pattern:
   - Accept QueryManagerConfig
   - Store config as private readonly fields
   - Initialize empty Maps for queries and hybridQueries

3. Owned state (single source of truth):
   - `private queries: Map<string, QueryHandle<any>> = new Map()`
   - `private hybridQueries: Map<string, HybridQueryHandle<any>> = new Map()`

4. Move these methods from SyncEngine (lines ~638-785, ~2410-2611):

   **Standard queries:**
   - `subscribeToQuery(query)` - Add to queries Map, send subscription if authenticated
   - `unsubscribeFromQuery(queryId)` - Remove from Map, send unsub if authenticated
   - `sendQuerySubscription(query)` - Internal method to send QUERY_SUB message

   **Hybrid queries:**
   - `subscribeToHybridQuery<T>(query)` - Add to hybridQueries Map, send subscription
   - `unsubscribeFromHybridQuery(queryId)` - Remove from Map, send unsub
   - `sendHybridQuerySubscription(query)` - Internal method to send HYBRID_QUERY_SUBSCRIBE
   - `getHybridQuery(queryId)` - Retrieve hybrid query by ID

   **Local query execution:**
   - `runLocalQuery(mapName, filter)` - Execute query against storage adapter
   - `runLocalHybridQuery<T>(mapName, filter)` - Execute hybrid query locally

5. Add `resubscribeAll()` method:
   - Called by SyncEngine after AUTH_ACK
   - Loop through all queries and call sendQuerySubscription
   - Loop through all hybridQueries and call sendHybridQuerySubscription

6. Message sending:
   - Use `this.config.sendMessage({type: 'QUERY_SUB', ...})` pattern
   - Query subscription message format:
     ```typescript
     { type: 'QUERY_SUB', payload: { queryId, mapName, query: filter } }
     ```
   - Hybrid subscription message format from existing code

7. Update index.ts:
   - Add export for QueryManager
  </action>
  <verify>
TypeScript compiles: `cd packages/client && npx tsc --noEmit`
  </verify>
  <done>
QueryManager class exists with all query subscription and local query methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate QueryManager into SyncEngine</name>
  <files>
    packages/client/src/SyncEngine.ts
  </files>
  <action>
Refactor SyncEngine to use QueryManager:

1. Add imports:
   - Import `QueryManager`, `QueryManagerConfig` from `./sync`

2. Constructor changes:
   - Remove queries and hybridQueries Map initialization (QueryManager owns them)
   - Create QueryManager with config:
     ```typescript
     this.queryManager = new QueryManager({
       storageAdapter: this.storageAdapter,
       sendMessage: (msg, key) => this.webSocketManager.sendMessage(msg, key),
       isAuthenticated: () => this.isAuthenticated(),
     });
     ```

3. Remove migrated methods from SyncEngine:
   - Delete `subscribeToQuery()` - delegate to queryManager
   - Delete `unsubscribeFromQuery()` - delegate to queryManager
   - Delete `sendQuerySubscription()` - moved to QueryManager
   - Delete `subscribeToHybridQuery()` - delegate to queryManager
   - Delete `unsubscribeFromHybridQuery()` - delegate to queryManager
   - Delete `sendHybridQuerySubscription()` - moved to QueryManager
   - Delete `runLocalQuery()` - delegate to queryManager
   - Delete `runLocalHybridQuery()` - delegate to queryManager

4. Add delegation methods in SyncEngine (maintain public API):
   ```typescript
   public subscribeToQuery(query: QueryHandle<any>): void {
     this.queryManager.subscribeToQuery(query);
   }

   public unsubscribeFromQuery(queryId: string): void {
     this.queryManager.unsubscribeFromQuery(queryId);
   }

   // ... same pattern for all query methods
   ```

5. Update AUTH_ACK handler:
   - Replace loop over `this.queries` with `this.queryManager.resubscribeAll()`
   - Remove manual query resubscription code

6. Update QUERY_RESP handler:
   - Replace `this.queries.get(payload.queryId)` with `this.queryManager.getQueries().get(payload.queryId)`

7. Update HYBRID_QUERY_RESPONSE/HYBRID_QUERY_UPDATED handlers:
   - Replace `this.hybridQueries.get()` with `this.queryManager.getHybridQuery()`

8. Remove now-unused fields:
   - `private queries: Map<string, QueryHandle<any>>`
   - `private hybridQueries: Map<string, HybridQueryHandle<any>>`
  </action>
  <verify>
All tests pass: `cd packages/client && pnpm test`
  </verify>
  <done>
SyncEngine delegates all query operations to QueryManager, tests pass, ~290 lines of query logic extracted
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds: `cd packages/client && npx tsc --noEmit`
2. All existing tests pass: `cd packages/client && pnpm test`
3. QueryManager file exists at `packages/client/src/sync/QueryManager.ts`
4. SyncEngine no longer has direct query Map handling
5. Query subscription/unsubscription behavior unchanged
6. Local query execution works correctly
</verification>

<success_criteria>
- QueryManager class extracted with ~290 lines of query logic
- SyncEngine reduced by ~290 lines (now uses QueryManager)
- queries and hybridQueries Maps owned by QueryManager
- All existing client tests continue to pass
- No public API changes to SyncEngine
</success_criteria>

<output>
After completion, create `.planning/phases/05-syncengine-refactor/05-02-SUMMARY.md`
</output>
