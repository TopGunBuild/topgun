---
id: RES-003
topic: Storage Architecture for TopGun Rust Server
created: 2026-02-19
status: complete
---

# Research: Multi-Layer Storage Architecture for TopGun Rust Server

## Summary

Hazelcast's three-layer storage hierarchy (Storage -> RecordStore -> MapDataStore) provides the ideal architectural template for TopGun's Rust server. Combined with TiKV's Rust trait composition patterns (Arc wrapping, extension traits, engine/snapshot separation) and Databend's OpenDAL layer composition for pluggable object storage, a complete trait hierarchy emerges that supports Phase 3 (PostgreSQL only) through Phase 5 (S3, tiered hot/cold, write-behind) without requiring trait redesign. The recommended approach uses three trait layers: `StorageEngine` (in-memory KV), `RecordStore` (CRDT metadata + orchestration), and `MapDataStore` (external persistence), with a `MutationObserver` pattern for decoupled notifications to indexes, query caches, and event publishers.

## Background

TODO-080 was created during the Phase 2.5 Architecture Research Sprint to prevent embedding TypeScript storage limitations into the Rust codebase. The TS server uses a single `IServerStorage` interface with 8 flat methods (load/store/delete for single and batch operations). This design has no concept of:

- Record metadata (version, timestamps, hit count) needed for eviction
- TTL/expiry management
- Write-through vs write-behind persistence strategies
- MutationObserver pattern for decoupled notifications
- Caller provenance tracking (client vs backup vs replication)
- Cursor-based iteration for large datasets
- Eviction policies (LRU, LFU, random sampling)

All of these are required by Phase 4-5 features and cannot be retrofitted onto a flat trait. The research examines three reference codebases to design the right architecture upfront.

---

## Options Explored

### Option 1: Extended Flat Trait (TS-style)

**Description:** Keep a single `ServerStorage` trait but add methods for TTL, eviction, metadata, etc.

**Pros:**
- Simplest migration from existing `ServerStorage` trait
- Single trait to implement per backend
- Fewer indirection layers

**Cons:**
- Violates Single Responsibility: one trait handles KV, metadata, persistence, and eviction
- Every new backend must implement ALL methods (S3 doesn't need eviction, in-memory doesn't need flush)
- Cannot compose write-through/write-behind without duplicating the entire trait
- No clean place for MutationObserver (cross-cutting concern)
- Impossible to have different in-memory and persistence backends independently

### Option 2: Two-Layer (StorageEngine + DataStore)

**Description:** Separate in-memory storage from external persistence. A `StorageManager` composes them.

**Pros:**
- Clear separation of in-memory vs persistent concerns
- Independent backend implementations (DashMap for memory, PostgreSQL for persistence)
- Write-behind can wrap the DataStore layer independently

**Cons:**
- No place for record metadata management (who tracks version, hits, timestamps?)
- No eviction logic (which layer decides when to evict?)
- MutationObserver pattern has no natural home
- Caller provenance tracking falls through the cracks
- Essentially recreates the TS problem with one extra layer

### Option 3: Three-Layer Hazelcast-Informed (Recommended)

**Description:** Three distinct trait layers matching Hazelcast's proven architecture:
1. `StorageEngine` — in-memory KV with cursor iteration (Hazelcast `Storage<K,R>`)
2. `RecordStore` — record metadata, TTL, eviction, observer notifications (Hazelcast `RecordStore<R>`)
3. `MapDataStore` — external persistence with write-through/write-behind (Hazelcast `MapDataStore<K,V>`)

**Pros:**
- Battle-tested architecture (Hazelcast: 15+ years in production)
- Each layer has a clear, single responsibility
- Independent backend implementations at each layer
- MutationObserver fits naturally on RecordStore (the mutation orchestrator)
- Write-behind is a MapDataStore wrapper, not a trait change
- S3 is another MapDataStore implementation, not a new architecture
- Tiered storage composes at both Layer 1 (hot/cold memory) and Layer 3 (hot/cold persistence)
- CallerProvenance flows through RecordStore to decide persistence behavior

**Cons:**
- More complex initial implementation (3 traits vs 1)
- More indirection for simple get/put operations
- Requires understanding the full hierarchy to implement a new feature

---

## Codebase Findings

### TopGun TS Server (`packages/server/src/storage/`)

- **`IServerStorage`** (`IServerStorage.ts`) — 8 methods, flat interface, mapName in every call
- **`PostgresAdapter`** (`PostgresAdapter.ts`) — Direct `pg` pool usage, upsert pattern, JSONB values
- **`MemoryServerAdapter`** (`MemoryServerAdapter.ts`) — `Map<string, Map<string, StorageValue>>`, trivial
- **`StorageValue`** type — Union of `LWWRecord | ORMapValue | ORMapTombstones`, discriminated by `type` field
- **`createStorageAdapter`** (`createStorageAdapter.ts`) — Factory that creates adapters by mode string
- **No record metadata, no TTL, no eviction, no observer pattern, no provenance tracking**

### TopGun Rust Codebase

- **`ServerStorage`** (`packages/server-rust/src/traits.rs`) — Direct port of TS `IServerStorage`, 8 async methods
- **`MapProvider`** (`packages/server-rust/src/traits.rs`) — Tiered-aware map access, already has `get_or_load_map()` pattern
- **`StorageValue`** (`packages/core-rust/src/types.rs`) — Opaque `Vec<u8>` blob, no typed access
- **`RecordValue` types exist in HLC module** (`packages/core-rust/src/hlc.rs`) — `LWWRecord<V>`, `ORMapRecord<V>` with timestamps
- **`Value` enum** (`packages/core-rust/src/types.rs`) — Full JSON-compatible value type (Null, Bool, Int, Float, String, Bytes, Array, Map)

### Hazelcast Reference

| File | Role | Key Patterns |
|------|------|--------------|
| `Storage.java` | Layer 1 | `put/get/remove`, `mutationTolerantIterator()`, `fetchKeys(cursor, size)`, `getRandomSamples(count)`, `EntryCostEstimator` |
| `RecordStore.java` | Layer 2 | 90+ methods, TTL/expiry, eviction, `CallerProvenance`, `MapDataStore` integration, `MutationObserver`, backup operations, map loading |
| `MapDataStore.java` | Layer 3 | `add/remove/load/loadAll`, `softFlush()` / `hardFlush()`, `isPostProcessingMapStore()`, write-behind queue |
| `DefaultRecordStore.java` | Layer 2 impl | 1749 lines, `putInternal()` with `StaticParams`, `CompositeMutationObserver`, `MapKeyLoader`, `ExpirySystem` |
| `Record.java` | Record interface | `version`, `creationTime`, `lastAccessTime`, `lastUpdateTime`, `lastStoredTime`, `hits`, `cost`, `onAccess()`, `onUpdate()`, `onStore()` |
| `CallerProvenance.java` | Enum | `WAN` vs `NOT_WAN` (TopGun extends this to 5 variants) |
| `MutationObserver.java` | Observer trait | `onPutRecord`, `onUpdateRecord`, `onRemoveRecord`, `onEvictRecord`, `onLoadRecord`, `onReplicationPutRecord`, `onClear`, `onReset`, `onDestroy` |
| `CompositeMutationObserver.java` | Fan-out | Iterates observers, first error collected, all observers called |

### TiKV Reference

| File | Role | Key Patterns |
|------|------|--------------|
| `engine.rs` | `KvEngine` trait | Supertrait composition: `Peekable + SyncMutable + Iterable + WriteBatchExt + ...`, `type Snapshot`, `Arc<DB>` wrapping |
| `peekable.rs` | `Peekable` trait | `get_value(key)`, `get_value_cf(cf, key)`, `get_msg<M>()` — column family aware reads |
| `iterable.rs` | `Iterable` trait | `iterator_opt(cf, opts)`, `scan(cf, start, end, f)`, `seek(cf, key)` — cursor-based |
| `write_batch.rs` | `WriteBatch` trait | `put/delete/delete_range`, `write_opt(opts)`, `set_save_point()`, `rollback_to_save_point()` |
| `lib.rs` | Module structure | Extension trait pattern: `WriteBatchExt`, `CfNamesExt`, `CompactExt`, etc. |

### Databend Reference

| File | Role | Key Patterns |
|------|------|--------------|
| `operator.rs` | OpenDAL integration | `StorageParams` enum (S3/GCS/Azure/Fs/Memory/...), `init_operator()` factory, layer composition: `Timeout -> Runtime -> HttpClient -> Retry -> Logging -> Tracing -> Metrics`, `DataOperator` wrapper with `Arc<Operator>` |

---

## Trade-offs Analysis

| Aspect | Option 1: Flat Trait | Option 2: Two-Layer | Option 3: Three-Layer (Recommended) |
|--------|---------------------|---------------------|-------------------------------------|
| **Implementation complexity (Phase 3)** | Low | Medium | Medium-High |
| **Phase 5 extensibility** | Poor (breaking changes needed) | Medium (some refactoring) | Excellent (additive only) |
| **Backend independence** | Poor (all-or-nothing) | Good (memory vs persist) | Excellent (3 independent axes) |
| **Record metadata** | Bolted on | Unclear ownership | Clear: RecordStore owns it |
| **Eviction** | Part of flat trait | Unclear which layer | RecordStore policy + Storage sampling |
| **Write-behind** | Requires new trait | DataStore wrapper | MapDataStore wrapper (clean) |
| **S3 support** | New backend for entire trait | New DataStore impl | New MapDataStore impl only |
| **Observer pattern** | Ad-hoc hooks | External to both layers | Built into RecordStore |
| **Provenance tracking** | Missing | DataStore parameter | RecordStore orchestrates |
| **Hazelcast alignment** | None | Partial | Direct mapping |
| **TiKV patterns** | N/A | Partial | Arc wrapping, extension traits |
| **Lines of trait code** | ~50 | ~120 | ~300 |
| **Lines of Phase 3 impl** | ~300 | ~500 | ~800 |

---

## Recommendations

**Recommended approach:** Option 3 — Three-Layer Hazelcast-Informed Architecture

**Reasoning:**

1. **Proven architecture**: Hazelcast's three-layer model has been production-tested for 15+ years across enterprise deployments. The layer boundaries have survived numerous feature additions (tiered storage, WAN replication, Hot Restart persistence) without architectural changes.

2. **Phase 5 trait stability**: Every Phase 5 feature (S3, write-behind, tiered hot/cold) maps to a new implementation of an EXISTING trait. No trait signatures need to change. This is the core deliverable requirement of TODO-080.

3. **CRDT-native record metadata**: TopGun's CRDTs need HLC timestamps for conflict resolution, version counters for backup consistency, and access statistics for eviction. The `Record` + `RecordMetadata` structs provide a natural home for all of this.

4. **MutationObserver is essential**: TopGun needs to update Merkle trees, notify live query subscriptions, and publish topic events on every write. The observer pattern decouples these concerns from the write path without performance overhead (observers are called synchronously on the partition thread).

5. **Rust trait composition is well-suited**: TiKV demonstrates that Rust's trait system handles multi-layer storage abstractions cleanly with `Arc<dyn Trait>` for shared ownership and `async_trait` for async operations.

6. **Moderate additional Phase 3 cost**: The three-layer design adds roughly 500 lines of trait definitions and 300 lines of additional boilerplate compared to the flat approach. This is a one-time cost that prevents multiple refactoring rounds in Phase 5.

**Implementation notes:**

1. **Phase 3 scope**: Implement `StorageEngine` (trait + HashMapStorage), `RecordStore` (trait + DefaultRecordStore), `MapDataStore` (trait + WriteThroughPostgresDataStore + NullDataStore), `Record/RecordMetadata/RecordValue`, `MutationObserver` (trait + CompositeMutationObserver), `CallerProvenance`, `ExpiryPolicy`. Skip eviction policy implementations (use NONE/disabled) — Phase 5 adds LRU/LFU.

2. **File limit**: Respect the 5-files-per-spec rule. Split into two specs:
   - SPEC-A: Traits + Record types (`engine.rs`, `record.rs`, `record_store.rs`, `map_data_store.rs`, `mutation_observer.rs`)
   - SPEC-B: Implementations (`hashmap.rs`, `postgres.rs`, `null.rs`, `default_record_store.rs`, `factory.rs`)

3. **Replace, don't extend**: The current `ServerStorage` trait in `server-rust/src/traits.rs` should be replaced entirely. The `MapProvider` trait stays as-is (it already has the right abstraction level).

4. **RecordValue replaces StorageValue**: The opaque `StorageValue { data: Vec<u8> }` in `core-rust/src/types.rs` should be deprecated in favor of the typed `RecordValue` enum defined in the storage module.

---

## References

### Codebase Files

- `/Users/koristuvac/Projects/topgun/topgun/packages/server/src/storage/IServerStorage.ts` — TS storage interface (behavioral reference)
- `/Users/koristuvac/Projects/topgun/topgun/packages/server/src/storage/PostgresAdapter.ts` — TS PostgreSQL implementation
- `/Users/koristuvac/Projects/topgun/topgun/packages/server-rust/src/traits.rs` — Current Rust traits (to be replaced)
- `/Users/koristuvac/Projects/topgun/topgun/packages/core-rust/src/types.rs` — Current `StorageValue`, `Value`, `CrdtMap` types
- `/Users/koristuvac/Projects/topgun/topgun/packages/core-rust/src/hlc.rs` — HLC, `Timestamp`, `LWWRecord`, `ORMapRecord`

### Hazelcast Reference Files

- `/Users/koristuvac/Projects/hazelcast/.../Storage.java` — Layer 1 interface (cursor iteration, cost estimation, eviction sampling)
- `/Users/koristuvac/Projects/hazelcast/.../RecordStore.java` — Layer 2 interface (90+ methods, full record lifecycle)
- `/Users/koristuvac/Projects/hazelcast/.../MapDataStore.java` — Layer 3 interface (write-through/write-behind abstraction)
- `/Users/koristuvac/Projects/hazelcast/.../DefaultRecordStore.java` — Layer 2 implementation (orchestration logic)
- `/Users/koristuvac/Projects/hazelcast/.../Record.java` — Record metadata interface (version, timestamps, hits, cost)
- `/Users/koristuvac/Projects/hazelcast/.../MutationObserver.java` — Observer trait for mutation notifications
- `/Users/koristuvac/Projects/hazelcast/.../CompositeMutationObserver.java` — Fan-out observer implementation
- `/Users/koristuvac/Projects/hazelcast/.../CallerProvenance.java` — Write origin enum

### TiKV Reference Files

- `/Users/koristuvac/Projects/rust/tikv/components/engine_traits/src/engine.rs` — `KvEngine` supertrait with extension trait pattern
- `/Users/koristuvac/Projects/rust/tikv/components/engine_traits/src/peekable.rs` — `Peekable` trait for single-key reads
- `/Users/koristuvac/Projects/rust/tikv/components/engine_traits/src/iterable.rs` — `Iterable` + `Iterator` traits for range scans
- `/Users/koristuvac/Projects/rust/tikv/components/engine_traits/src/write_batch.rs` — `WriteBatch` + `WriteBatchExt` traits

### Databend Reference Files

- `/Users/koristuvac/Projects/rust/databend/src/common/storage/src/operator.rs` — OpenDAL `Operator` factory with layer composition pattern

### External References

- [Apache OpenDAL Documentation](https://docs.rs/opendal/latest/opendal/) — Unified data access layer for Rust
- [TiKV engine_traits Design](https://github.com/tikv/tikv/tree/master/components/engine_traits) — Storage abstraction patterns
- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/) — Extension trait and newtype patterns

### Architecture Document

- `/Users/koristuvac/Projects/topgun/topgun/.specflow/reference/RUST_STORAGE_ARCHITECTURE.md` — Full architecture design with trait definitions, struct layouts, file organization, and Phase 3-to-5 migration path
