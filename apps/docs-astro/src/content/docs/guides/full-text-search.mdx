---
title: Full-Text Search
description: Add fast text search to your data with InvertedIndex and BM25 relevance ranking. Configure tokenization, filters, and search strategies for product catalogs, document search, and more.
order: 14
---

import CodeBlock from '../../../components/docs/CodeBlock.astro';
import { ChevronRight, Search, Filter, Settings, Zap, Star, Server, Shield } from 'lucide-react';
import { FeatureCard } from '../../../components/docs/FeatureCard';

export const basicSearchCode = `import {
  IndexedLWWMap,
  simpleAttribute,
  HLC
} from '@topgunbuild/core';

interface Product {
  id: string;
  name: string;
  description: string;
  tags: string[];
}

const hlc = new HLC('node-1');
const products = new IndexedLWWMap<string, Product>(hlc);

// Add inverted index on text fields
const nameAttr = simpleAttribute<Product, string>('name', p => p.name);
products.addInvertedIndex(nameAttr);

// Add some products
products.set('p1', {
  id: 'p1',
  name: 'Wireless Bluetooth Mouse',
  description: 'Ergonomic design with 6 buttons',
  tags: ['electronics', 'wireless', 'mouse']
});

products.set('p2', {
  id: 'p2',
  name: 'USB-C Wireless Keyboard',
  description: 'Mechanical switches with RGB',
  tags: ['electronics', 'wireless', 'keyboard']
});

// Search for products containing "wireless"
const results = products.queryValues({
  type: 'contains',
  attribute: 'name',
  value: 'wireless'
});
// Returns both products (both names contain "wireless")`;

export const queryTypesCode = `// 1. contains - All tokens must match (AND semantics)
const wireless = products.queryValues({
  type: 'contains',
  attribute: 'name',
  value: 'wireless mouse'  // Matches: "wireless" AND "mouse"
});
// Returns: [{ name: 'Wireless Bluetooth Mouse', ... }]

// 2. containsAll - All specified values must match
const withTags = products.queryValues({
  type: 'containsAll',
  attribute: 'name',
  values: ['wireless', 'bluetooth']
});
// Returns: [{ name: 'Wireless Bluetooth Mouse', ... }]

// 3. containsAny - Any token matches (OR semantics)
const anyMatch = products.queryValues({
  type: 'containsAny',
  attribute: 'name',
  values: ['keyboard', 'mouse']
});
// Returns both products`;

export const tokenizationCode = `import {
  TokenizationPipeline,
  WordBoundaryTokenizer,
  LowercaseFilter,
  MinLengthFilter,
  StopWordFilter
} from '@topgunbuild/core';

// Simple pipeline (default)
const simple = TokenizationPipeline.simple();
simple.process("Hello World!");
// → ["hello", "world"]

// Search pipeline (with stop words removed)
const search = TokenizationPipeline.search();
search.process("The quick brown fox");
// → ["quick", "brown", "fox"]  ("the" removed as stop word)

// Custom pipeline
const custom = TokenizationPipeline.custom(
  new WordBoundaryTokenizer(),
  [
    new LowercaseFilter(),
    new MinLengthFilter(3),     // Min 3 characters
    new StopWordFilter()        // Remove common words
  ]
);
custom.process("I have a wireless mouse");
// → ["wireless", "mouse"]  ("i", "have", "a" removed)`;

export const pipelinesCode = `// Available tokenizers:
// - WhitespaceTokenizer: splits on whitespace
// - WordBoundaryTokenizer: splits on word boundaries (default)
// - NGramTokenizer: generates n-grams for substring matching

// Available filters:
// - LowercaseFilter: converts to lowercase
// - MinLengthFilter(n): removes tokens shorter than n
// - MaxLengthFilter(n): removes tokens longer than n
// - StopWordFilter: removes common words (the, a, is, etc.)
// - TrimFilter: trims whitespace
// - UniqueFilter: removes duplicate tokens`;

export const customPipelineCode = `import {
  IndexedLWWMap,
  simpleAttribute,
  TokenizationPipeline,
  NGramTokenizer,
  LowercaseFilter,
  HLC
} from '@topgunbuild/core';

// N-gram pipeline for substring matching
const ngramPipeline = TokenizationPipeline.custom(
  new NGramTokenizer(3),  // 3-character n-grams
  [new LowercaseFilter()]
);

const products = new IndexedLWWMap<string, Product>(hlc);

// Use custom pipeline for description field
const descAttr = simpleAttribute<Product, string>('description', p => p.description);
products.addInvertedIndex(descAttr, ngramPipeline);

// Now substring matches work
products.set('p1', { id: 'p1', description: 'Ergonomic mouse' });
const results = products.queryValues({
  type: 'contains',
  attribute: 'description',
  value: 'rgo'  // Matches "Ergonomic" via n-gram
});`;

export const multiFieldCode = `import { multiAttribute } from '@topgunbuild/core';

// Index an array field (tags)
const tagsAttr = multiAttribute<Product, string>('tags', p => p.tags);
products.addInvertedIndex(tagsAttr);

// Each tag becomes searchable
const wirelessProducts = products.queryValues({
  type: 'contains',
  attribute: 'tags',
  value: 'wireless'
});`;

export const combinedQueryCode = `// Combine text search with other predicates
const results = products.queryValues({
  type: 'and',
  children: [
    { type: 'contains', attribute: 'name', value: 'wireless' },
    { type: 'eq', attribute: 'status', value: 'active' },
    { type: 'between', attribute: 'price', from: 10, to: 100 }
  ]
});

// Query optimizer will use:
// - InvertedIndex for "contains"
// - HashIndex for "eq" (if indexed)
// - NavigableIndex for "between" (if indexed)`;

export const statsCode = `// Get extended statistics for inverted index
const index = products.getIndexes().find(i => i.type === 'inverted');
if (index) {
  const stats = index.getExtendedStats();
  console.log(\`Unique tokens: \${stats.totalTokens}\`);
  console.log(\`Documents indexed: \${stats.totalEntries}\`);
  console.log(\`Avg tokens/doc: \${stats.avgTokensPerDocument.toFixed(1)}\`);
  console.log(\`Max docs/token: \${stats.maxDocumentsPerToken}\`);
}`;

export const bm25BasicCode = `import { IndexedORMap, HLC } from '@topgunbuild/core';

interface Article {
  title: string;
  body: string;
  author: string;
}

const hlc = new HLC('node-1');
const articles = new IndexedORMap<string, Article>(hlc);

// Enable BM25 full-text search on title and body fields
articles.enableFullTextSearch({
  fields: ['title', 'body']
});

// Add some articles
articles.add('a1', {
  title: 'Introduction to Machine Learning',
  body: 'Machine learning is a subset of artificial intelligence...',
  author: 'Alice'
});

articles.add('a2', {
  title: 'Deep Learning Tutorial',
  body: 'Deep learning uses neural networks with many layers...',
  author: 'Bob'
});

articles.add('a3', {
  title: 'Getting Started with AI',
  body: 'Artificial intelligence is transforming industries...',
  author: 'Charlie'
});

// Search with BM25 relevance ranking
const results = articles.search('machine learning');
// Results sorted by relevance score:
// [
//   { key: 'a1', score: 2.34, matchedTerms: ['machin', 'learn'], value: {...} },
//   { key: 'a2', score: 0.89, matchedTerms: ['learn'], value: {...} }
// ]`;

export const bm25OptionsCode = `// Search with options
const results = articles.search('artificial intelligence', {
  limit: 10,           // Maximum results to return
  minScore: 0.5,       // Minimum relevance score threshold
  boost: {             // Field boosting weights
    title: 2.0,        // Title matches worth 2x
    body: 1.0          // Body matches worth 1x (default)
  }
});

// Results are ranked by weighted BM25 scores
for (const result of results) {
  console.log(\`[\${result.score.toFixed(2)}] \${result.value.title}\`);
  console.log(\`  Matched terms: \${result.matchedTerms.join(', ')}\`);
}`;

export const bm25ConfigCode = `// Configure tokenizer and BM25 parameters
articles.enableFullTextSearch({
  fields: ['title', 'body', 'tags'],

  // Tokenizer options
  tokenizer: {
    minLength: 2,        // Minimum token length (default: 2)
    maxLength: 50,       // Maximum token length (default: 50)
    lowercase: true,     // Convert to lowercase (default: true)
    // Uses Porter stemmer and 174 English stopwords by default
  },

  // BM25 scoring parameters
  bm25: {
    k1: 1.2,  // Term frequency saturation (default: 1.2)
              // Higher = more weight to term frequency
    b: 0.75   // Document length normalization (default: 0.75)
              // 0 = no normalization, 1 = full normalization
  }
});`;

export const bm25VsInvertedCode = `// Two approaches to full-text search:

// 1. InvertedIndex - Boolean matching (fast, no ranking)
const nameAttr = simpleAttribute<Product, string>('name', p => p.name);
products.addInvertedIndex(nameAttr);
const matches = products.queryValues({
  type: 'contains',
  attribute: 'name',
  value: 'wireless mouse'
});
// Returns all products containing both "wireless" AND "mouse"
// No relevance score, order is arbitrary

// 2. BM25 Search - Relevance ranking (search engine style)
products.enableFullTextSearch({ fields: ['name', 'description'] });
const ranked = products.search('wireless mouse');
// Returns products sorted by relevance
// "Wireless Bluetooth Mouse" ranks higher than "Mouse pad for wireless setup"
// Each result includes: score, matchedTerms`;

export const bm25SerializationCode = `// Serialize index for persistence
const ftsIndex = articles.getFullTextIndex();
const serialized = ftsIndex.serialize();

// Save to storage (IndexedDB, localStorage, file, etc.)
localStorage.setItem('fts-index', JSON.stringify(serialized));

// Later: restore from storage
const saved = JSON.parse(localStorage.getItem('fts-index'));
ftsIndex.load(saved);

// Index is ready to use immediately
const results = articles.search('machine learning');`;

export const serverSearchSetupCode = `import { ServerCoordinator } from '@topgunbuild/server';

const server = new ServerCoordinator({
  port: 8080,
  // Enable full-text search for specific maps
  fullTextSearch: {
    articles: {
      fields: ['title', 'body'],
      tokenizer: { minLength: 2 },
      bm25: { k1: 1.2, b: 0.75 }
    },
    products: {
      fields: ['name', 'description', 'tags']
    }
  }
});

await server.start();
// Server now maintains FTS indexes for 'articles' and 'products' maps
// Indexes are automatically updated when data changes
// Indexes are backfilled from storage on startup`;

export const clientSearchCode = `import { TopGunClient } from '@topgunbuild/client';

const client = new TopGunClient({
  serverUrl: 'ws://localhost:8080'
});

await client.authenticate({ token: 'user-token' });

// Search articles on the server
const results = await client.search<Article>('articles', 'machine learning', {
  limit: 20,
  minScore: 0.5,
  boost: { title: 2.0, body: 1.0 }
});

// Results are sorted by relevance
for (const result of results) {
  console.log(\`[\${result.score.toFixed(2)}] \${result.key}: \${result.value.title}\`);
  console.log(\`  Matched: \${result.matchedTerms.join(', ')}\`);
}`;

export const clientSearchResultCode = `// SearchResult<T> interface
interface SearchResult<T> {
  key: string;        // Document key
  value: T;           // Full document value
  score: number;      // BM25 relevance score
  matchedTerms: string[];  // Stemmed terms that matched
}

// Example result
const result: SearchResult<Article> = {
  key: 'a1',
  value: { title: 'Introduction to ML', body: '...' },
  score: 2.34,
  matchedTerms: ['machin', 'learn']  // Stemmed
};`;

export const liveSearchCode = `import { TopGunClient } from '@topgunbuild/client';

const client = new TopGunClient({
  serverUrl: 'ws://localhost:8080'
});

// Create a live search subscription
const handle = client.searchSubscribe<Article>('articles', 'machine learning', {
  limit: 20,
  minScore: 0.5,
  boost: { title: 2.0, body: 1.0 }
});

// Subscribe to result changes (includes initial results + delta updates)
const unsubscribe = handle.subscribe((results) => {
  console.log('Search results updated:', results.length);
  for (const result of results) {
    console.log(\`[\${result.score.toFixed(2)}] \${result.key}: \${result.value.title}\`);
  }
});

// Get current results snapshot at any time
const snapshot = handle.getResults();

// Update query dynamically (re-subscribes automatically)
handle.setQuery('deep learning');

// Cleanup when done
handle.dispose();`;

export const liveSearchDeltaCode = `// Delta update types:
// - ENTER: Document now matches the query (was added or score increased above minScore)
// - UPDATE: Document still matches but score/value changed
// - LEAVE: Document no longer matches (was removed or score dropped below minScore)

// The SearchHandle maintains a sorted result set internally.
// Your subscribe callback receives the full sorted array on each change.

// Example: Building a real-time search UI
const handle = client.searchSubscribe<Product>('products', 'wireless');

handle.subscribe((results) => {
  // Results are always sorted by score (highest first)
  renderSearchResults(results);
});

// When a product matching "wireless" is added to the 'products' map,
// or an existing product's text is updated to include "wireless",
// your callback fires with the updated results array.`;

export const reactSearchCode = `import { useSearch } from '@topgunbuild/react';

function SearchResults() {
  const [searchTerm, setSearchTerm] = useState('');

  const { results, loading, error } = useSearch<Article>('articles', searchTerm, {
    limit: 20,
    boost: { title: 2.0 }
  });

  if (loading) return <Spinner />;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {results.map(r => (
        <li key={r.key}>
          [{r.score.toFixed(2)}] {r.value.title}
          <small>Matched: {r.matchedTerms.join(', ')}</small>
        </li>
      ))}
    </ul>
  );
}`;

export const reactSearchDebounceCode = `import { useSearch } from '@topgunbuild/react';
import { useState } from 'react';

function SearchInput() {
  const [input, setInput] = useState('');

  // Debounce search queries by 300ms to avoid excessive server requests
  const { results, loading, error } = useSearch<Product>('products', input, {
    debounceMs: 300,  // Wait 300ms after user stops typing
    limit: 10,
    minScore: 0.5
  });

  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Search products..."
      />
      {loading && <span>Searching...</span>}
      {error && <span className="error">{error.message}</span>}
      <ul>
        {results.map(r => (
          <li key={r.key}>{r.value.name} - \${r.value.price}</li>
        ))}
      </ul>
    </div>
  );
}`;

export const serverSearchPermissionsCode = `// Server security configuration
const server = new ServerCoordinator({
  port: 8080,
  fullTextSearch: {
    articles: { fields: ['title', 'body'] }
  },
  security: {
    permissions: {
      // Users need READ permission to search a map
      articles: {
        read: ['user', 'admin'],
        write: ['admin']
      }
    }
  }
});

// Client-side: search requires READ permission
try {
  const results = await client.search('articles', 'query');
} catch (error) {
  // Error: Permission denied for map: articles
}`;

<div className="flex items-center gap-2 text-sm text-neutral-500 mb-8 overflow-hidden whitespace-nowrap">
  <span className="text-foreground font-medium">Docs</span>
  <ChevronRight className="w-4 h-4" />
  <a href="/docs/guides" className="hover:text-foreground transition-colors">Guides</a>
  <ChevronRight className="w-4 h-4" />
  <span className="text-foreground font-medium">Full-Text Search</span>
</div>

# Full-Text Search

TopGun's **InvertedIndex** provides fast full-text search with O(K) performance, where K is the number of matching tokens. On 100K documents, text search drops from 50-100ms (full scan) to **under 1ms**.

<div className="grid md:grid-cols-3 gap-6 mb-16 not-prose">
  <FeatureCard
    icon={Search}
    iconColor="text-blue-500"
    title="Token-Based Search"
    description="Inverted index maps tokens to documents for instant lookups."
  />
  <FeatureCard
    icon={Filter}
    iconColor="text-green-500"
    title="Flexible Tokenization"
    description="Configure tokenizers and filters for your use case."
  />
  <FeatureCard
    icon={Zap}
    iconColor="text-yellow-500"
    title="CRDT Integration"
    description="Indexes update automatically on set, remove, and merge operations."
  />
</div>

## Basic Usage

Add an `InvertedIndex` to enable text search on a field:

<div className="not-prose">
  <CodeBlock title="Basic Text Search" language="typescript" code={basicSearchCode} />
</div>

## Query Types

InvertedIndex supports three query types with different matching semantics:

<div className="not-prose">
  <CodeBlock title="Query Types" language="typescript" code={queryTypesCode} />
</div>

| Query Type | Semantics | Use Case |
|-----------|-----------|----------|
| `contains` | All tokens must match (AND) | Search box with multiple words |
| `containsAll` | All values must be present | Filter by required tags |
| `containsAny` | Any token matches (OR) | Search with alternatives |

## Tokenization Pipeline

Text is processed through a **tokenization pipeline** before indexing and searching:

<div className="not-prose">
  <CodeBlock title="Tokenization Pipeline" language="typescript" code={tokenizationCode} />
</div>

### Pre-built Pipelines

| Pipeline | Tokenizer | Filters | Best For |
|----------|-----------|---------|----------|
| `simple()` | WordBoundary | Lowercase, MinLength(2) | General use |
| `search()` | WordBoundary | Lowercase, MinLength(2), StopWords | Search engines |
| `minimal()` | WordBoundary | Lowercase only | Preserve all tokens |

### Available Components

<div className="not-prose">
  <CodeBlock title="Tokenizers & Filters" language="typescript" code={pipelinesCode} />
</div>

## Custom Pipelines

Create custom pipelines for specialized use cases:

<div className="not-prose">
  <CodeBlock title="N-Gram Pipeline for Substring Matching" language="typescript" code={customPipelineCode} />
</div>

<div className="bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-500 p-4 my-6 not-prose">
  <p className="text-sm text-blue-800 dark:text-blue-200">
    <strong>N-gram tip:</strong> N-grams enable substring matching but increase memory usage significantly.
    Use only when needed (e.g., autocomplete, partial name matching).
  </p>
</div>

## Multi-Value Fields

Index array fields like tags using `multiAttribute`:

<div className="not-prose">
  <CodeBlock title="Indexing Array Fields" language="typescript" code={multiFieldCode} />
</div>

## Combined Queries

Combine text search with other index types for powerful filtering:

<div className="not-prose">
  <CodeBlock title="Combining with Other Indexes" language="typescript" code={combinedQueryCode} />
</div>

The Query Optimizer automatically selects the best index for each part of the query.

## BM25 Ranked Search

For search-engine-style relevance ranking, TopGun provides **BM25 full-text search**. Unlike InvertedIndex (boolean matching), BM25 scores documents by relevance and returns results sorted by score.

<div className="grid md:grid-cols-2 gap-6 mb-8 not-prose">
  <FeatureCard
    icon={Star}
    iconColor="text-purple-500"
    title="Relevance Ranking"
    description="BM25 algorithm scores documents based on term frequency and document length."
  />
  <FeatureCard
    icon={Search}
    iconColor="text-blue-500"
    title="Porter Stemming"
    description="Words are stemmed (running→run) for better matching with 174 English stopwords."
  />
</div>

### Basic Usage

Enable BM25 search on an `IndexedORMap`:

<div className="not-prose">
  <CodeBlock title="BM25 Ranked Search" language="typescript" code={bm25BasicCode} />
</div>

### Search Options

Control search behavior with options:

<div className="not-prose">
  <CodeBlock title="Search Options" language="typescript" code={bm25OptionsCode} />
</div>

### Configuration

Customize tokenization and BM25 parameters:

<div className="not-prose">
  <CodeBlock title="BM25 Configuration" language="typescript" code={bm25ConfigCode} />
</div>

### BM25 vs InvertedIndex

Choose the right approach for your use case:

<div className="not-prose">
  <CodeBlock title="Comparison" language="typescript" code={bm25VsInvertedCode} />
</div>

| Feature | InvertedIndex | BM25 Search |
|---------|---------------|-------------|
| **Query method** | `queryValues({ type: 'contains' })` | `search('query')` |
| **Ranking** | No ranking (boolean match) | Relevance-sorted by score |
| **Stemming** | Optional (via pipeline) | Built-in Porter stemmer |
| **Stopwords** | Optional (via pipeline) | 174 English stopwords |
| **Best for** | Filtering, exact matches | Search boxes, content discovery |
| **Works with** | IndexedLWWMap, IndexedORMap | IndexedORMap |

### Index Persistence

Serialize and restore the BM25 index:

<div className="not-prose">
  <CodeBlock title="Index Serialization" language="typescript" code={bm25SerializationCode} />
</div>

<div className="bg-purple-50 dark:bg-purple-900/20 border-l-4 border-purple-500 p-4 my-6 not-prose">
  <p className="text-sm text-purple-800 dark:text-purple-200">
    <strong>Performance tip:</strong> BM25 index builds in &lt;100ms for 1K documents. Search queries complete in &lt;10ms. For large datasets, consider serializing the index to avoid rebuilding on page load.
  </p>
</div>

## Server-Side Search

For multi-client applications, TopGun supports **server-side BM25 search**. The server maintains indexes centrally, eliminating the need for each client to build and store indexes locally.

<div className="grid md:grid-cols-2 gap-6 mb-8 not-prose">
  <FeatureCard
    icon={Server}
    iconColor="text-green-500"
    title="Centralized Indexes"
    description="Server maintains FTS indexes, clients query via WebSocket."
  />
  <FeatureCard
    icon={Shield}
    iconColor="text-red-500"
    title="Permission-Based"
    description="Search respects RBAC - users need READ permission to search a map."
  />
</div>

### Server Configuration

Enable FTS on the server for specific maps:

<div className="not-prose">
  <CodeBlock title="Server Setup" language="typescript" code={serverSearchSetupCode} />
</div>

The server will:
- Create and maintain BM25 indexes for configured maps
- Automatically update indexes when data changes (add/update/remove)
- Backfill indexes from persistent storage on startup

### Client API

Search from the client using `client.search()`:

<div className="not-prose">
  <CodeBlock title="Client Search" language="typescript" code={clientSearchCode} />
</div>

### Search Result Structure

Each result includes the document key, value, relevance score, and matched terms:

<div className="not-prose">
  <CodeBlock title="SearchResult Interface" language="typescript" code={clientSearchResultCode} />
</div>

### Permissions

Server-side search respects the security model - users must have READ permission on a map to search it:

<div className="not-prose">
  <CodeBlock title="Permissions" language="typescript" code={serverSearchPermissionsCode} />
</div>

<div className="bg-green-50 dark:bg-green-900/20 border-l-4 border-green-500 p-4 my-6 not-prose">
  <p className="text-sm text-green-800 dark:text-green-200">
    <strong>When to use server-side search:</strong> Use server-side search when you have multiple clients, need centralized index management, or want to offload search computation from clients. Use local BM25 (IndexedORMap) for offline-first apps where clients need to search without server connectivity.
  </p>
</div>

## Live Search Subscriptions

For real-time search UIs, TopGun provides **Live Search subscriptions** that automatically update when matching documents change. Unlike the one-shot `search()` method, `searchSubscribe()` pushes delta updates to your callback.

<div className="grid md:grid-cols-2 gap-6 mb-8 not-prose">
  <FeatureCard
    icon={Zap}
    iconColor="text-yellow-500"
    title="Real-Time Updates"
    description="Results update automatically when documents are added, modified, or removed."
  />
  <FeatureCard
    icon={Filter}
    iconColor="text-green-500"
    title="Delta Updates"
    description="Server sends ENTER/UPDATE/LEAVE events instead of full result sets."
  />
</div>

### Client API

Create a live search subscription with `searchSubscribe()`:

<div className="not-prose">
  <CodeBlock title="Live Search Subscription" language="typescript" code={liveSearchCode} />
</div>

### Delta Update Types

The server sends incremental updates instead of full result sets:

<div className="not-prose">
  <CodeBlock title="Delta Updates" language="typescript" code={liveSearchDeltaCode} />
</div>

| Update Type | When Sent |
|-------------|-----------|
| `ENTER` | Document now matches query (added or score increased above threshold) |
| `UPDATE` | Document still matches but score or value changed |
| `LEAVE` | Document no longer matches (removed or score dropped below threshold) |

## React Integration

The `@topgunbuild/react` package provides the `useSearch` hook for easy integration with React applications:

### Basic Usage

<div className="not-prose">
  <CodeBlock title="useSearch Hook" language="typescript" code={reactSearchCode} />
</div>

### With Debounce

For search-as-you-type interfaces, use the `debounceMs` option to avoid excessive server requests:

<div className="not-prose">
  <CodeBlock title="Debounced Search" language="typescript" code={reactSearchDebounceCode} />
</div>

### useSearch Return Values

| Property | Type | Description |
|----------|------|-------------|
| `results` | `SearchResult<T>[]` | Current search results sorted by score |
| `loading` | `boolean` | True while waiting for initial results |
| `error` | `Error \| null` | Error if search failed |

### useSearch Options

| Option | Type | Description |
|--------|------|-------------|
| `limit` | `number` | Maximum results to return |
| `minScore` | `number` | Minimum BM25 score threshold |
| `boost` | `Record<string, number>` | Field boost weights |
| `debounceMs` | `number` | Debounce delay for query changes |

<div className="bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-500 p-4 my-6 not-prose">
  <p className="text-sm text-blue-800 dark:text-blue-200">
    <strong>See Also:</strong> The <a href="/docs/reference/react-hooks" className="underline">React Hooks Reference</a> for all available hooks.
  </p>
</div>

## Index Statistics

Monitor your inverted index with extended statistics:

<div className="not-prose">
  <CodeBlock title="Index Statistics" language="typescript" code={statsCode} />
</div>

## Performance Characteristics

| Metric | Value |
|--------|-------|
| **Query complexity** | O(K) where K = matching tokens |
| **Index memory overhead** | 30-50% of text data |
| **Index update time** | < 10μs per document |
| **Supported operations** | contains, containsAll, containsAny, has |

### Memory Usage

Inverted indexes store:
- **Token index**: `Map<Token, Set<Key>>` - tokens to document keys
- **Reverse index**: `Map<Key, Set<Token>>` - document keys to tokens (for updates)

For text-heavy documents, expect 30-50% memory overhead. Monitor with `getExtendedStats()`.

## Best Practices

1. **Choose the right pipeline**
   - `simple()` for general use
   - `search()` for search boxes (removes noise words)
   - Custom N-gram for autocomplete/substring matching

2. **Index selectively**
   - Only index fields users actually search
   - Long text fields increase memory usage

3. **Combine with other indexes**
   - Use HashIndex for category filtering
   - Use NavigableIndex for date/price ranges
   - Let the optimizer combine them efficiently

4. **Test your tokenization**
   ```typescript
   const pipeline = TokenizationPipeline.search();
   console.log(pipeline.process("your sample text"));
   // Verify tokens match your expectations
   ```

## Next Steps

- [Indexing](/docs/guides/indexing) - Overview of all index types
- [Adaptive Indexing](/docs/guides/adaptive-indexing) - Auto-suggest and auto-create indexes
- [Live Queries](/docs/guides/live-queries) - Combine search with real-time updates

<div className="flex justify-between pt-10 mt-10 border-t border-card-border not-prose">
  <a href="/docs/guides/indexing" className="group flex flex-col gap-1 px-6 py-4 rounded-lg border border-card-border hover:border-neutral-400 dark:hover:border-neutral-700 transition-colors">
    <span className="text-xs text-neutral-500">Previous</span>
    <div className="flex items-center gap-2 text-foreground font-semibold">
      <ChevronRight className="w-4 h-4 rotate-180 group-hover:-translate-x-1 transition-transform" /> Indexing
    </div>
  </a>
  <a href="/docs/guides/adaptive-indexing" className="group flex flex-col items-end gap-1 px-6 py-4 rounded-lg border border-card-border hover:border-neutral-400 dark:hover:border-neutral-700 transition-colors">
    <span className="text-xs text-neutral-500">Next</span>
    <div className="flex items-center gap-2 text-foreground font-semibold">
      Adaptive Indexing <ChevronRight className="w-4 h-4 group-hover:translate-x-1 transition-transform" />
    </div>
  </a>
</div>
