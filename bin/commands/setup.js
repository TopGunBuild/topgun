const inquirer = require('inquirer');
const chalk = require('chalk');
const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');

module.exports = async function setup(options) {
  console.log(chalk.bold('\n TopGun Setup Wizard\n'));

  let config = {
    storage: options.storage || 'sqlite',
    installK6: false,
    devContainer: false,
  };

  // Interactive mode (unless --yes)
  if (!options.yes) {
    const answers = await inquirer.prompt([
      {
        type: 'list',
        name: 'storage',
        message: 'Storage backend:',
        choices: [
          { name: 'SQLite (no Docker needed, dev only)', value: 'sqlite' },
          { name: 'PostgreSQL (recommended for production)', value: 'postgres' },
          { name: 'Memory (testing only)', value: 'memory' },
        ],
        default: 'sqlite',
      },
      {
        type: 'confirm',
        name: 'installK6',
        message: 'Install k6 for load testing? (requires Docker)',
        default: false,
      },
      {
        type: 'confirm',
        name: 'devContainer',
        message: 'Configure Dev Container for VS Code/Codespaces?',
        default: false,
      },
    ]);
    config = { ...config, ...answers };
  }

  // Step 1: Create .env file
  console.log(chalk.cyan('\n[1/4] Creating .env file...'));
  const envContent = generateEnvFile(config);
  fs.writeFileSync(path.join(process.cwd(), '.env'), envContent);
  console.log(chalk.green('  ✓ .env created'));

  // Step 2: Install dependencies
  console.log(chalk.cyan('\n[2/4] Installing dependencies...'));
  if (!fs.existsSync(path.join(process.cwd(), 'node_modules'))) {
    try {
      execSync('pnpm install', { stdio: 'inherit' });
      console.log(chalk.green('  ✓ Dependencies installed'));
    } catch (error) {
      console.error(chalk.red('  ✗ Failed to install dependencies'));
      process.exit(1);
    }
  } else {
    console.log(chalk.green('  ✓ Dependencies already installed'));
  }

  // Step 3: Build packages
  console.log(chalk.cyan('\n[3/4] Building packages...'));
  const distPath = path.join(process.cwd(), 'packages/server/dist');
  if (!fs.existsSync(distPath)) {
    try {
      execSync('pnpm build', { stdio: 'inherit' });
      console.log(chalk.green('  ✓ Build complete'));
    } catch (error) {
      console.error(chalk.red('  ✗ Build failed'));
      process.exit(1);
    }
  } else {
    console.log(chalk.green('  ✓ Already built'));
  }

  // Step 4: Start PostgreSQL (if selected)
  if (config.storage === 'postgres') {
    console.log(chalk.cyan('\n[4/4] Starting PostgreSQL...'));
    try {
      execSync('docker compose up -d postgres', { stdio: 'inherit' });
      console.log(chalk.green('  ✓ PostgreSQL started'));

      // Wait for PostgreSQL to be ready
      console.log(chalk.gray('  Waiting for PostgreSQL to be ready...'));
      await waitForPostgres();
      console.log(chalk.green('  ✓ PostgreSQL is ready'));
    } catch (error) {
      console.error(chalk.red('  ✗ Failed to start PostgreSQL'));
      console.log(chalk.yellow('  Hint: Make sure Docker is running'));
      process.exit(1);
    }
  } else {
    console.log(chalk.cyan('\n[4/4] Skipping database (SQLite mode)'));
    console.log(chalk.green('  ✓ SQLite will be used'));
  }

  // Done!
  console.log(chalk.bold.green('\n Setup complete!\n'));
  console.log(chalk.white('  Run:'));
  console.log(chalk.cyan('    npx topgun dev'));
  console.log(chalk.white('\n  Server will start at http://localhost:8080\n'));
};

function generateEnvFile(config) {
  const lines = [
    '# TopGun Configuration',
    `# Generated by 'topgun setup' on ${new Date().toISOString()}`,
    '',
    '# Storage',
    `STORAGE_MODE=${config.storage}`,
  ];

  if (config.storage === 'sqlite') {
    lines.push('DB_PATH=./topgun.db');
  } else if (config.storage === 'postgres') {
    lines.push('DB_HOST=localhost');
    lines.push('DB_PORT=5432');
    lines.push('DB_USER=topgun');
    lines.push('DB_PASSWORD=topgun_dev');
    lines.push('DB_NAME=topgun');
    lines.push('DATABASE_URL=postgresql://topgun:topgun_dev@localhost:5432/topgun');
  }

  lines.push('');
  lines.push('# Server');
  lines.push('SERVER_PORT=8080');
  lines.push('METRICS_PORT=9091');
  lines.push('');
  lines.push('# Debug (enable for development)');
  lines.push('# TOPGUN_DEBUG=true  # Enables all debug features (CRDT, Search, endpoints)');
  lines.push('# LOG_LEVEL=debug');

  return lines.join('\n') + '\n';
}

async function waitForPostgres(maxAttempts = 30) {
  for (let i = 0; i < maxAttempts; i++) {
    try {
      execSync('docker compose exec -T postgres pg_isready -U topgun', {
        stdio: 'ignore',
      });
      return;
    } catch {
      await new Promise((r) => setTimeout(r, 1000));
    }
  }
  throw new Error('PostgreSQL did not become ready');
}
