//! Cross-language compatibility integration tests.
//!
//! Reads golden MsgPack fixture files generated by the TypeScript fixture
//! generator (`packages/core/src/__tests__/cross-lang-fixtures.test.ts`) and
//! verifies that Rust can decode them and re-encode to identical structure.

use std::fs;
use std::path::PathBuf;

use topgun_core::messages::Message;
use topgun_core::messages::http_sync::{HttpSyncRequest, HttpSyncResponse};

/// Returns the path to the fixtures directory.
fn fixtures_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures")
}

/// Reads a fixture file by name and returns its bytes.
fn read_fixture(name: &str) -> Vec<u8> {
    let path = fixtures_dir().join(format!("{name}.msgpack"));
    fs::read(&path).unwrap_or_else(|e| panic!("Failed to read fixture {name}: {e}"))
}

/// All Message enum fixture names (59 fixtures -- excludes HTTP_SYNC_* standalone types).
const MESSAGE_FIXTURES: &[&str] = &[
    // Base domain
    "AUTH",
    "AUTH_REQUIRED",
    // Sync domain
    "CLIENT_OP",
    "OP_BATCH",
    "SYNC_INIT",
    "SYNC_RESP_ROOT",
    "SYNC_RESP_BUCKETS",
    "MERKLE_REQ_BUCKET",
    "OP_ACK",
    "OP_REJECTED",
    "BATCH",
    "ORMAP_SYNC_INIT",
    // Query domain
    "QUERY_SUB",
    "QUERY_UNSUB",
    "QUERY_RESP",
    "QUERY_UPDATE",
    // Search domain
    "SEARCH",
    "SEARCH_RESP",
    "SEARCH_SUB",
    "SEARCH_UPDATE",
    "SEARCH_UNSUB",
    // Cluster domain
    "PARTITION_MAP_REQUEST",
    "PARTITION_MAP",
    "CLUSTER_SUB_REGISTER",
    "CLUSTER_SUB_ACK",
    "CLUSTER_SUB_UPDATE",
    "CLUSTER_SUB_UNREGISTER",
    "CLUSTER_SEARCH_REQ",
    "CLUSTER_SEARCH_RESP",
    "CLUSTER_SEARCH_SUBSCRIBE",
    "CLUSTER_SEARCH_UNSUBSCRIBE",
    "CLUSTER_SEARCH_UPDATE",
    // Messaging domain
    "TOPIC_SUB",
    "TOPIC_UNSUB",
    "TOPIC_PUB",
    "TOPIC_MESSAGE",
    "LOCK_REQUEST",
    "LOCK_RELEASE",
    "COUNTER_REQUEST",
    "COUNTER_SYNC",
    "PING",
    "PONG",
    "ENTRY_PROCESS",
    "ENTRY_PROCESS_RESPONSE",
    "JOURNAL_SUBSCRIBE",
    "JOURNAL_EVENT",
    "REGISTER_RESOLVER",
    "MERGE_REJECTED",
    "LIST_RESOLVERS",
    "LIST_RESOLVERS_RESPONSE",
    // Client events domain
    "SERVER_EVENT",
    "SERVER_BATCH_EVENT",
    "GC_PRUNE",
    "AUTH_ACK",
    "AUTH_FAIL",
    "ERROR",
    "LOCK_GRANTED",
    "LOCK_RELEASED",
    "SYNC_RESET_REQUIRED",
];

// ---------------------------------------------------------------------------
// AC-1: All Message variants decode from TS-produced MsgPack
// ---------------------------------------------------------------------------

#[test]
fn all_message_fixtures_decode() {
    let mut success_count = 0;
    let mut failures = Vec::new();

    for name in MESSAGE_FIXTURES {
        let bytes = read_fixture(name);
        match rmp_serde::from_slice::<Message>(&bytes) {
            Ok(_) => success_count += 1,
            Err(e) => failures.push(format!("{name}: {e}")),
        }
    }

    if !failures.is_empty() {
        panic!(
            "Failed to decode {}/{} fixtures:\n{}",
            failures.len(),
            MESSAGE_FIXTURES.len(),
            failures.join("\n")
        );
    }

    assert_eq!(success_count, MESSAGE_FIXTURES.len());
}

// ---------------------------------------------------------------------------
// AC-3: Round-trip fidelity (TS encode -> Rust decode -> Rust re-encode)
// ---------------------------------------------------------------------------

#[test]
fn message_fixtures_roundtrip() {
    let mut success_count = 0;
    let mut failures = Vec::new();

    for name in MESSAGE_FIXTURES {
        let bytes = read_fixture(name);

        // Decode
        let msg: Message = match rmp_serde::from_slice(&bytes) {
            Ok(m) => m,
            Err(e) => {
                failures.push(format!("{name}: decode failed: {e}"));
                continue;
            }
        };

        // Re-encode
        let re_encoded = match rmp_serde::to_vec_named(&msg) {
            Ok(b) => b,
            Err(e) => {
                failures.push(format!("{name}: re-encode failed: {e}"));
                continue;
            }
        };

        // Decode the re-encoded bytes
        let roundtripped: Message = match rmp_serde::from_slice(&re_encoded) {
            Ok(m) => m,
            Err(e) => {
                failures.push(format!("{name}: roundtrip decode failed: {e}"));
                continue;
            }
        };

        // Compare decoded structs (semantic equality)
        if msg != roundtripped {
            failures.push(format!("{name}: roundtrip mismatch"));
            continue;
        }

        success_count += 1;
    }

    if !failures.is_empty() {
        panic!(
            "Roundtrip failed for {}/{} fixtures:\n{}",
            failures.len(),
            MESSAGE_FIXTURES.len(),
            failures.join("\n")
        );
    }

    assert_eq!(success_count, MESSAGE_FIXTURES.len());
}

// ---------------------------------------------------------------------------
// AC-4: Optional field omission verification
// ---------------------------------------------------------------------------

#[test]
fn optional_fields_omitted_in_auth_ack() {
    // AUTH_ACK has optional protocolVersion. Verify the re-encoded bytes
    // when protocolVersion is None do NOT contain the key.
    let bytes = read_fixture("AUTH_ACK");
    let msg: Message = rmp_serde::from_slice(&bytes).expect("decode AUTH_ACK");

    // Re-encode with None values by constructing a new instance
    let msg_no_optional = Message::AuthAck(topgun_core::messages::AuthAckData {
        protocol_version: None,
    });

    let re_bytes = rmp_serde::to_vec_named(&msg_no_optional).expect("re-encode");

    // Parse as raw Value and verify no "protocolVersion" key
    let raw: rmpv::Value =
        rmpv::decode::read_value(&mut &re_bytes[..]).expect("decode as Value");
    let map = raw.as_map().expect("should be map");

    let has_protocol_version = map
        .iter()
        .any(|(k, _)| k.as_str() == Some("protocolVersion"));
    assert!(
        !has_protocol_version,
        "protocolVersion=None should not produce a key in MsgPack"
    );

    // Verify the original fixture DOES have protocolVersion (since it was set to 1)
    let _ = msg; // original fixture has protocolVersion: 1
}

#[test]
fn optional_fields_omitted_in_partition_map_request() {
    // PARTITION_MAP_REQUEST has optional payload field in the Message enum.
    // Test that when payload is None, no "payload" key appears.
    let msg_no_payload = Message::PartitionMapRequest { payload: None };
    let bytes = rmp_serde::to_vec_named(&msg_no_payload).expect("encode");

    let raw: rmpv::Value =
        rmpv::decode::read_value(&mut &bytes[..]).expect("decode as Value");
    let map = raw.as_map().expect("should be map");

    let has_payload = map.iter().any(|(k, _)| k.as_str() == Some("payload"));
    assert!(
        !has_payload,
        "payload=None should not produce a 'payload' key"
    );

    // Verify it only has the "type" key
    let type_entry = map
        .iter()
        .find(|(k, _)| k.as_str() == Some("type"))
        .expect("should have 'type' key");
    assert_eq!(type_entry.1.as_str(), Some("PARTITION_MAP_REQUEST"));
}

#[test]
fn optional_fields_omitted_in_lock_request() {
    // LOCK_REQUEST has optional ttl field.
    let msg_no_ttl = Message::LockRequest {
        payload: topgun_core::messages::LockRequestPayload {
            request_id: "test".into(),
            name: "test-lock".into(),
            ttl: None,
        },
    };
    let bytes = rmp_serde::to_vec_named(&msg_no_ttl).expect("encode");

    let raw: rmpv::Value =
        rmpv::decode::read_value(&mut &bytes[..]).expect("decode as Value");
    let map = raw.as_map().expect("should be map");

    // The payload should be a nested map that does NOT contain "ttl"
    let payload_entry = map
        .iter()
        .find(|(k, _)| k.as_str() == Some("payload"))
        .expect("should have 'payload' key");
    let payload_map = payload_entry.1.as_map().expect("payload should be map");

    let has_ttl = payload_map.iter().any(|(k, _)| k.as_str() == Some("ttl"));
    assert!(!has_ttl, "ttl=None should not produce a 'ttl' key");
}

// ---------------------------------------------------------------------------
// AC-6: Discriminated union routing
// ---------------------------------------------------------------------------

#[test]
fn message_enum_routes_by_type_discriminator() {
    // Verify that different fixtures deserialize to the correct variant
    let auth_bytes = read_fixture("AUTH");
    let auth: Message = rmp_serde::from_slice(&auth_bytes).expect("decode AUTH");
    assert!(matches!(auth, Message::Auth(_)));

    let ping_bytes = read_fixture("PING");
    let ping: Message = rmp_serde::from_slice(&ping_bytes).expect("decode PING");
    assert!(matches!(ping, Message::Ping(_)));

    let search_bytes = read_fixture("SEARCH");
    let search: Message = rmp_serde::from_slice(&search_bytes).expect("decode SEARCH");
    assert!(matches!(search, Message::Search { .. }));

    let journal_bytes = read_fixture("JOURNAL_EVENT");
    let journal: Message = rmp_serde::from_slice(&journal_bytes).expect("decode JOURNAL_EVENT");
    assert!(matches!(journal, Message::JournalEvent { .. }));

    let partition_bytes = read_fixture("PARTITION_MAP_REQUEST");
    let partition: Message =
        rmp_serde::from_slice(&partition_bytes).expect("decode PARTITION_MAP_REQUEST");
    assert!(matches!(partition, Message::PartitionMapRequest { .. }));
}

// ---------------------------------------------------------------------------
// AC-8 (http-sync-roundtrip): Standalone HTTP sync types
// ---------------------------------------------------------------------------

#[test]
fn http_sync_request_decodes_from_ts_fixture() {
    let bytes = read_fixture("HTTP_SYNC_REQUEST");
    let req: HttpSyncRequest =
        rmp_serde::from_slice(&bytes).expect("decode HttpSyncRequest");

    assert_eq!(req.client_id, "client-1");
    assert!(!req.client_id.is_empty());

    // Verify round-trip
    let re_encoded = rmp_serde::to_vec_named(&req).expect("re-encode");
    let roundtripped: HttpSyncRequest =
        rmp_serde::from_slice(&re_encoded).expect("roundtrip decode");
    assert_eq!(req, roundtripped);
}

#[test]
fn http_sync_response_decodes_from_ts_fixture() {
    let bytes = read_fixture("HTTP_SYNC_RESPONSE");
    let resp: HttpSyncResponse =
        rmp_serde::from_slice(&bytes).expect("decode HttpSyncResponse");

    assert_eq!(resp.server_hlc.millis, 1_700_000_000_000);
    assert!(resp.ack.is_some());
    assert!(resp.deltas.is_some());

    // Verify round-trip
    let re_encoded = rmp_serde::to_vec_named(&resp).expect("re-encode");
    let roundtripped: HttpSyncResponse =
        rmp_serde::from_slice(&re_encoded).expect("roundtrip decode");
    assert_eq!(resp, roundtripped);
}

// ---------------------------------------------------------------------------
// Coverage check: at least 40 distinct fixture files
// ---------------------------------------------------------------------------

#[test]
fn at_least_40_fixture_files_exist() {
    let dir = fixtures_dir();
    let count = fs::read_dir(&dir)
        .expect("read fixtures dir")
        .filter_map(|e| e.ok())
        .filter(|e| {
            e.path()
                .extension()
                .is_some_and(|ext| ext == "msgpack")
        })
        .count();

    assert!(
        count >= 40,
        "Expected at least 40 fixture files, found {count}"
    );
}
