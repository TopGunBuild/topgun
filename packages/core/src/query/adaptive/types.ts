/**
 * Types for Adaptive Indexing System (Phase 8.02)
 *
 * Defines interfaces for query pattern tracking, index suggestions,
 * and auto-indexing configuration.
 *
 * @module query/adaptive/types
 */

/**
 * Query type for pattern tracking.
 * Matches the query types from QueryTypes.ts and indexes/types.ts
 */
export type TrackedQueryType =
  | 'eq'
  | 'neq'
  | 'gt'
  | 'gte'
  | 'lt'
  | 'lte'
  | 'between'
  | 'in'
  | 'has'
  | 'contains'
  | 'containsAll'
  | 'containsAny'
  | 'compound'; // Phase 9.03: Compound query patterns

/**
 * Statistics for a single attribute + query type combination.
 */
export interface QueryStatistics {
  /** Attribute name being queried */
  attribute: string;
  /** Type of query (eq, gt, between, etc.) */
  queryType: TrackedQueryType;
  /** Number of times this pattern was queried */
  queryCount: number;
  /** Cumulative execution time in milliseconds */
  totalCost: number;
  /** Average execution time per query */
  averageCost: number;
  /** Timestamp of last query */
  lastQueried: number;
  /** Estimated result size (max observed) */
  estimatedCardinality: number;
  /** Whether an index exists for this attribute */
  hasIndex: boolean;
}

/**
 * Statistics for compound query patterns (Phase 9.03).
 * Tracks AND combinations of attributes for compound index suggestions.
 */
export interface CompoundQueryStatistics {
  /** Attribute names in the compound query (sorted) */
  attributes: string[];
  /** Combined key for identification */
  compoundKey: string;
  /** Number of times this pattern was queried */
  queryCount: number;
  /** Cumulative execution time in milliseconds */
  totalCost: number;
  /** Average execution time per query */
  averageCost: number;
  /** Timestamp of last query */
  lastQueried: number;
  /** Whether a compound index exists for this combination */
  hasCompoundIndex: boolean;
}

/**
 * Index type recommendation.
 */
export type RecommendedIndexType = 'hash' | 'navigable' | 'inverted' | 'compound';

/**
 * Priority level for index suggestions.
 */
export type SuggestionPriority = 'high' | 'medium' | 'low';

/**
 * Index suggestion generated by IndexAdvisor.
 */
export interface IndexSuggestion {
  /** Attribute to index (or compound key for compound indexes) */
  attribute: string;
  /** Recommended index type */
  indexType: RecommendedIndexType;
  /** Human-readable explanation */
  reason: string;
  /** Expected performance improvement multiplier */
  estimatedBenefit: number;
  /** Estimated memory overhead in bytes */
  estimatedCost: number;
  /** Priority based on query patterns */
  priority: SuggestionPriority;
  /** Query count that triggered this suggestion */
  queryCount: number;
  /** Average query cost in milliseconds */
  averageCost: number;
  /** For compound indexes: array of attribute names in order */
  compoundAttributes?: string[];
}

/**
 * Options for getting index suggestions.
 */
export interface IndexSuggestionOptions {
  /** Minimum query count to consider (default: 10) */
  minQueryCount?: number;
  /** Minimum average cost in ms to consider (default: 1) */
  minAverageCost?: number;
  /** Whether to exclude already indexed attributes (default: true) */
  excludeExistingIndexes?: boolean;
  /** Maximum number of suggestions to return (default: unlimited) */
  maxSuggestions?: number;
}

/**
 * Configuration for Index Advisor.
 */
export interface AdvisorConfig {
  /** Enable advisor mode (default: true) */
  enabled: boolean;
  /** Minimum query count before suggesting (default: 10) */
  minQueryCount?: number;
  /** Minimum average cost in ms to suggest (default: 1) */
  minAverageCost?: number;
}

/**
 * Callback for index creation events.
 */
export type IndexCreatedCallback = (attribute: string, indexType: RecommendedIndexType) => void;

/**
 * Configuration for Auto-Index Manager.
 */
export interface AutoIndexConfig {
  /** Enable auto-indexing (default: false) */
  enabled: boolean;
  /** Number of queries before auto-creating index (default: 10) */
  threshold?: number;
  /** Maximum number of auto-created indexes (default: 20) */
  maxIndexes?: number;
  /** Callback when index is automatically created */
  onIndexCreated?: IndexCreatedCallback;
}

/**
 * Default indexing strategy.
 * - 'none': No automatic indexing (default)
 * - 'scalar': Index all top-level scalar (primitive) fields
 * - 'all': Index all fields including nested (not recommended)
 */
export type DefaultIndexingStrategy = 'none' | 'scalar' | 'all';

/**
 * Complete adaptive indexing configuration.
 */
export interface AdaptiveIndexingConfig {
  /** Index Advisor configuration */
  advisor?: AdvisorConfig;
  /** Auto-Index Manager configuration */
  autoIndex?: AutoIndexConfig;
}

/**
 * Progress callback for lazy index building (Phase 9.01).
 */
export type IndexBuildProgressCallback = (
  attributeName: string,
  progress: number, // 0-100
  recordsProcessed: number,
  totalRecords: number
) => void;

/**
 * Extended options for IndexedLWWMap/IndexedORMap.
 */
export interface IndexedMapOptions {
  /** Adaptive indexing configuration */
  adaptiveIndexing?: AdaptiveIndexingConfig;
  /** Default indexing strategy (default: 'none') */
  defaultIndexing?: DefaultIndexingStrategy;
  /**
   * Enable lazy index building (Phase 9.01).
   * When true, indexes are not built until first query.
   * Default: false
   */
  lazyIndexBuilding?: boolean;
  /**
   * Callback for index building progress (Phase 9.01).
   * Called during lazy index materialization.
   */
  onIndexBuilding?: IndexBuildProgressCallback;
}

/**
 * Default values for adaptive indexing configuration.
 */
export const ADAPTIVE_INDEXING_DEFAULTS = {
  advisor: {
    enabled: true,
    minQueryCount: 10,
    minAverageCost: 1,
  },
  autoIndex: {
    enabled: false,
    threshold: 10,
    maxIndexes: 20,
  },
} as const;

/**
 * Sampling rate for query tracking (1 = track all, 10 = track 1 in 10).
 * Used to reduce overhead in high-throughput scenarios.
 */
export const TRACKING_SAMPLE_RATE = 1;

/**
 * Memory overhead estimation constants (bytes per record).
 */
export const MEMORY_OVERHEAD_ESTIMATES = {
  /** Hash index overhead per record */
  hash: 24,
  /** Navigable index overhead per record */
  navigable: 32,
  /** Inverted index overhead per record (depends on token count) */
  inverted: 48,
  /** Compound index overhead per record (includes composite key) */
  compound: 40,
} as const;
